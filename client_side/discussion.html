<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Threaded Opinions — Modern Chat Layout</title>
  <style>
    :root {
      --bg: #0b0c10;
      --panel: #151821;
      --panel-2: #10131a;
      --text: #e6e9ef;
      --muted: #a3aab9;
      --border: #232735;
      --primary: #7c5cff;
      --primary-2: #a590ff;
      --success: #22c55e;
      --danger: #ef4444;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius-sm: 12px;
      --radius-xs: 10px;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f7fb;
        --panel: #ffffff;
        --panel-2: #fbfbfe;
        --text: #0b1020;
        --muted: #606a80;
        --border: #e6e8ee;
        --shadow: 0 10px 30px rgba(9, 12, 22, .08);
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 700px at 80% -200px, rgba(124,92,255,.18), transparent 60%),
                  radial-gradient(1000px 500px at -200px 80%, rgba(79,209,197,.18), transparent 60%),
                  var(--bg);
      line-height: 1.5;
    }

    /* Layout */
    .shell {
      max-width: 1100px;
      margin: min(6vh, 48px) auto;
      padding: 0 20px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
    }

    .topic-card {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px 18px 2px 18px;
      position: sticky;
      top: 10px;
      z-index: 1;
    }

    .topic-heading {
      display: flex;
      align-items: start;
      gap: 14px;
    }
    .topic-icon {
      width: 44px; height: 44px;
      border-radius: 12px;
      display: grid; place-items: center;
      background: linear-gradient(145deg, rgba(124,92,255,.25), rgba(124,92,255,.05));
      border: 1px solid var(--border);
      flex: 0 0 auto;
    }
    .topic-title {
      margin: 0;
      font-size: clamp(22px, 2.5vw, 28px);
      letter-spacing: -0.01em;
    }
    .topic-meta {
      margin-top: 4px;
      color: var(--muted);
      font-size: 14px;
    }

    .toolbar {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }
    .toolbar .controls { display: flex; gap: 10px; flex-wrap: wrap; }

    .chip {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 14px;
      cursor: pointer;
    }

    .select {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
    }

    .list-card {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }

    /* Post item */
    .post {
      display: grid;
      grid-template-columns: 48px 1fr;
      gap: 12px;
      padding: 5px;
      border-radius: var(--radius-sm);
      border: 1px solid transparent;
      transition: border-color .2s ease, background .2s ease;
    }
    .post + .post { margin-top: 6px; }
    .post:hover { border-color: var(--border); background: rgba(124,92,255,.03); }

    .avatar {
      width: 48px; height: 48px; border-radius: 50%;
      background: linear-gradient(145deg, #d1d5db, #9ca3af);
      display: grid; place-items: center;
      color: #0b0c10; font-weight: 700;
      user-select: none;
    }

    .post-body { min-width: 0; }

    .post-head {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
    }
    .name { font-weight: 700; }
    .badge {
      font-size: 12px; padding: 2px 8px; border-radius: 999px;
      border: 1px solid var(--border); color: var(--muted);
    }
    .time { color: var(--muted); font-size: 13px; margin-left: auto; }

    .content { margin-top: 6px; font-size: 15.5px; }

    .attachments { margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap; }
    .pill {
      font-size: 12px; border: 1px dashed var(--border); color: var(--muted);
      padding: 6px 10px; border-radius: 999px;
    }

    .post-actions {
      margin-top: 10px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
    }
    .btn {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 12px; border-radius: 10px; border: 1px solid var(--border);
      background: transparent; color: var(--text); cursor: pointer; font-size: 14px;
    }
    .btn.primary { border-color: transparent; background: linear-gradient(145deg, var(--primary), var(--primary-2)); color: white; }
    .btn.ghost { opacity: .85; }
    .btn[aria-pressed="true"] { box-shadow: inset 0 0 0 2px currentColor; }

    .score { display: inline-flex; align-items: center; gap: 6px; font-size: 14px; color: var(--muted); margin-left: 2px; }
    .score .up { color: var(--success); }
    .score .down { color: var(--danger); }

    /* Replies */
    .replies {
      margin-top: 10px; padding-left: 18px; border-left: 2px dashed var(--border);
      display: grid; gap: 8px;
    }

    /* Composer */
    .composer {
      margin-top: 12px;
      display: grid; grid-template-columns: 48px 1fr; gap: 12px;
      padding: 12px; border: 1px dashed var(--border); border-radius: var(--radius-sm);
      background: rgba(124,92,255,.05);
    }
    textarea.input {
      width: 100%; min-height: 64px; resize: vertical;
      background: var(--panel-2); color: var(--text);
      border: 1px solid var(--border); border-radius: 12px;
      padding: 10px 12px; font: inherit;
    }
    .composer-actions { margin-top: 8px; display: flex; gap: 8px; align-items: center; justify-content: flex-end; }

    /* Utilities */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,1px,1px); border: 0; }
    .spacer { flex: 1; }

    /* Responsive tweaks */
    @media (max-width: 720px) {
      .topic-card { position: static; }
      .time { width: 100%; margin-left: 0; }
      .composer { grid-template-columns: 36px 1fr; }
      .avatar { width: 36px; height: 36px; font-size: 12px; }
      .post { grid-template-columns: 36px 1fr; }
    }

    .topic-description {
    margin-top: 10px;
    font-size: 14px;
    color: var(--muted);
    }
    .topic-description p {
    margin: 0;
    }
    .post.new-for-user { background: rgba(124,92,255,.08); border-color: var(--border); }

    /* tiny pill on disagreement buttons */
    .menu-badge{
    display:inline-flex; align-items:center; justify-content:center;
    margin-left:8px; padding:2px 8px; min-width:18px;
    font-size:12px; line-height:1; font-weight:600;
    border-radius:999px; color:#fff;
    background: linear-gradient(145deg, var(--primary), var(--primary-2));
    }


/* Sticky bar wrapper */
/* Sticky bar wrapper (keep as you had it) */
#disagreements-bar{
  position: sticky; top: 0; z-index: 1000;
  background: var(--panel, var(--surface));
  border-bottom: 1px solid var(--border);
}

/* Use grid so items fill 100% width when few, but scroll when many */
.disagreements-strip{
  display: grid;
  grid-auto-flow: column;                    /* lay chips in columns horizontally */
  grid-auto-columns: minmax(160px, 1fr);     /* each chip at least 160px, otherwise stretch equally */
  overflow-x: auto;                          /* scroll when too many chips to fit */
  scrollbar-width: thin;
}

/* Glued rectangular segments */
.disagreements-strip .chip{
  width: 100%;                               /* make each chip fill its grid column */
  display: inline-flex;
  align-items: center;
  justify-content: center;            /* room for title + badge */
  padding: 12px 14px;
  margin: 0;                                 /* glue: no gaps */
  border: 0;
  border-right: 1px solid var(--border);     /* vertical separators */
  border-radius: 0;                          /* square edges to glue seamlessly */
  background: var(--surface-2, #f7f7f8);
  color: var(--text);
  white-space: nowrap;
  cursor: pointer;
  text-align: center; 
}

.disagreements-strip .chip:first-child{
  border-left: 1px solid var(--border);
}

.disagreements-strip .chip[aria-pressed="true"]{
  background: var(--surface-3, #ececf1);
  font-weight: 600;
}

/* Badge (if you use it) */
.menu-badge{
  display:inline-flex; align-items:center; justify-content:center;
  margin-left:8px; padding:2px 8px; min-width:18px;
  font-size:12px; line-height:1; font-weight:600;
  border-radius:999px; color:#fff;
  background: linear-gradient(145deg, var(--primary), var(--primary-2));
}

/* Content offset so the sticky bar doesn't cover it */
body.has-sticky-bar{ --bar-h: 48px; padding-top: var(--bar-h); }

  </style>
</head>
<body>



  <div class="shell" role="application" aria-label="Threaded opinions" id="app">

    <!-- Top sticky disagreements bar -->
<nav id="disagreements-bar" aria-label="Disagreements switcher">
  <div id="disagreements-menu" class="disagreements-strip" role="tablist" aria-label="Disagreements">
    <!-- buttons injected by JS -->
  </div>
</nav>

    <!-- Topic/Header + Disagreement Switcher -->
    <section class="topic-card" aria-labelledby="topic-title">
      <div class="topic-heading">
        <div class="topic-icon" aria-hidden="true">💬</div>
        <div>
          <h1 id="topic-title" class="topic-title">Loading disagreements…</h1>
          <div class="topic-meta" id="topic-meta">Single-subject thread • <span id="opinion-count">0</span> opinions • Last sync <span id="last-sync">—</span></div>
        </div>
      </div>

      <div id="topic-description" class="topic-description"></div>

      <!-- <div class="toolbar" aria-label="Disagreements switcher">
        <div class="controls" id="disagreements-menu" style="overflow:auto; white-space:nowrap; padding-bottom:6px; width:100%">
        </div>
      </div> -->
    </section>

    <!-- Opinions List (dynamic) -->
    <section class="list-card" aria-live="polite">
      <div id="posts"></div>
    </section>

    <!-- New Opinion Composer (root-level) -->
    <section class="list-card" aria-label="Add new opinion">
      <div class="composer">
        <div class="avatar" aria-hidden="true" id="you-avatar">YOU</div>
        <div style="width:100%">
          <label class="sr-only" for="new-opinion">Share your opinion</label>
          <textarea id="new-opinion" class="input" placeholder="Share your opinion…"></textarea>
          <div class="composer-actions">
            <button class="btn" id="attach-btn" disabled>Attach</button>
            <span class="spacer"></span>
            <button class="btn primary" id="post-root">Post opinion</button>
          </div>
        </div>
      </div>
    </section>

  </div>

  <script src="js/disagreements.js"></script>

  <script>
    /* ===== Auth helpers (provided) ===== */
    function isLoggedIn() {
      const name = sessionStorage.getItem('participantName') || localStorage.getItem('participantName');
      const order = sessionStorage.getItem('snippetOrder') || localStorage.getItem('snippetOrder');
      return name && order;
    }
    function checkLogin() {
      if (!isLoggedIn()) {
        alert('You must be logged in to access this page. Redirecting to the homepage.');
        window.location.href = 'https://codecomprehensibility.site/';
      }
    }

    /* ===== Config ===== */
    const CONFIG = {
      DISAGREEMENTS_URL: 'js/disagreements.json',
      GET_LATEST_CHAT_URL: 'https://codecomprehensibility.site/get_latest_chat',
      SUBMIT_CHAT_URL: 'https://codecomprehensibility.site/submit_chat',   // TODO: confirm
      DELETE_CHAT_URL: 'https://codecomprehensibility.site/delete_chat',   // TODO: confirm
      POLL_MS: 120000
    };

    /* ===== App state ===== */
const state = {
  user: {
    name: sessionStorage.getItem('participantName') || localStorage.getItem('participantName') || 'You'
  },
  disagreements: [],
  currentId: null,
  chatsByDisagreement: {},
  previousLatestAt: '',      // from server (do not mutate)
  nowLatestAt: '',
  oldestReturnedAt: '',
  lastSeenByDis: {},         // ⬅️ per-disagreement baseline
  currentOpenedAt: '',       // ⬅️ baseline for currently open disagreement (set on switch)
  pollHandle: null
};



    /* ===== Utility ===== */
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    function fmtTime(iso) {
    if (!iso) return '';
    // Ensure string like "2025-08-14T16:03:25Z" or "...-04:00"
    // The Date ctor understands both and converts to the user's local tz for output.
    const d = new Date(iso);
    if (isNaN(d.getTime())) return ''; // safeguard
    // Use Intl to respect user locale + local time zone automatically
    return new Intl.DateTimeFormat(undefined, {
        year: 'numeric', month: 'short', day: '2-digit',
        hour: '2-digit', minute: '2-digit',
    }).format(d);
    }


    // Build a thread tree from flat messages
    function buildThread(messages) {
      const byId = new Map();
      const roots = [];
      messages.forEach(m => {
        m.children = [];
        byId.set(m.id, m);
      });
      messages.forEach(m => {
        if (m.parentId) {
          const p = byId.get(m.parentId);
          if (p) p.children.push(m); else roots.push(m); // orphan safeguard
        } else {
          roots.push(m);
        }
      });
      // sort by time ascending within each level (server may already do)
      const sortRec = nodes => {
        nodes.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt));
        nodes.forEach(n => sortRec(n.children));
      };
      sortRec(roots);
      return roots;
    }

    // On boot, mark body so CSS adds top padding
document.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('has-sticky-bar');
});

function renderDisagreementsMenu() {
  const menu = document.getElementById('disagreements-menu');
  if (!menu) return;
  menu.innerHTML = '';

  state.disagreements.forEach(d => {
    const btn = document.createElement('button');
    btn.className = 'chip';
    btn.type = 'button';
    btn.role = 'tab';
    btn.dataset.id = String(d.id);
    btn.setAttribute('aria-pressed', String(d.id === state.currentId));
    btn.textContent = d.title;          // ✅ title only; badges added later
    btn.onclick = () => switchDisagreement(d.id);
    menu.appendChild(btn);
  });

  updateDisagreementBadges();           // ✅ add badges after buttons exist
}



function switchDisagreement(newId){
  const prevId = state.currentId;

  // mark the one we're leaving as seen-now
  if (prevId != null) {
    state.lastSeenByDis[String(prevId)] = new Date(Date.now() - 1000).toISOString(); // now - 1s
  }

  state.currentId = newId;
  state.currentOpenedAt = new Date().toISOString();  // baseline for "arrived-while-open"
  saveSeenToStorage();

  // update pressed states
  document.querySelectorAll('#disagreements-menu .chip')
    .forEach(b => b.setAttribute('aria-pressed', String(b.dataset.id == newId)));

  const active = document.querySelector(`#disagreements-menu .chip[data-id="${newId}"]`);
  active?.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });

  const d = state.disagreements.find(x => String(x.id) === String(newId));
  if (d) {
    $('#topic-title').textContent = d.title;
    $('#topic-description').innerHTML = d.htmltext || '';
    $('#topic-meta').innerHTML = `Snippet ${d['snippet-id'] ?? d.snippet_id ?? '—'} • <span id="opinion-count">0</span> opinions • Last sync <span id="last-sync">—</span>`;
  }

  renderCurrentThread();
  updateDisagreementBadges();
}



    function renderCurrentThread() {
      const posts = $('#posts');
      posts.innerHTML = '';
      const msgs = state.chatsByDisagreement[state.currentId] || [];
      const thread = buildThread(msgs);
      $('#opinion-count').textContent = msgs.length;
      $('#last-sync').textContent = new Date().toLocaleTimeString();
      thread.forEach(node => posts.appendChild(renderMessage(node)));
    }

function renderMessage(msg) {
  const el = document.createElement('article');
  el.className = 'post';
  el.dataset.id = msg.id;

  const isRoot = !msg.parentId; // only roots can be replied to
    const isNew = isNewForUserIn(state.currentId, msg.createdAt);
    const newBadge = isNew
    ? `<span class="badge" style="border-color:transparent; background:linear-gradient(145deg,#ef4444,#dc2626); color:#fff;">NEW</span>`
    : '';




  el.innerHTML = `
    <div class="avatar" aria-hidden="true">${(msg.username || '?').slice(0,2).toUpperCase()}</div>
    <div class="post-body">
      <div class="post-head">
        <span class="name">${msg.username || 'Unknown'}</span>
        ${newBadge}
        ${msg.role ? `<span class="badge">${msg.role}</span>` : ''}
        <time class="time" datetime="${msg.createdAt || ''}">${fmtTime(msg.createdAt)}</time>
      </div>
      <div class="content">
        ${msg.is_deleted ? '<em style="color:var(--muted)">[message deleted]</em>' : escapeHtml(msg.content || '')}
      </div>
      <div class="post-actions">
        <button class="btn" onclick="vote(this, 1)">👍</button>
        <button class="btn" onclick="vote(this, -1)">👎</button>
        <span class="score"><span class="up" data-up>${msg.up || 0}</span>/<span class="down" data-down>${msg.down || 0}</span></span>
        <span class="spacer"></span>
        ${
          // ✅ show Reply ONLY for root, non-deleted
          (isRoot && !msg.is_deleted)
            ? `<button class="btn ghost" onclick="toggleReply(this)">↩︎ Reply</button>`
            : ``
        }
        ${
          // keep delete for the author if not deleted
          (msg.username === state.user.name && !msg.is_deleted)
            ? `<button class="btn ghost hidden" onclick="requestDelete('${msg.id}')" style="display: none;">🗑 Delete</button>`
            : ``
        }
        <button class="btn ghost" style="display: none;">⋯</button>
      </div>
    </div>
  `;

  // Replies container (always render so children show under any message)
  const repliesWrap = document.createElement('div');
  repliesWrap.className = 'replies';
  (msg.children || []).forEach(c => repliesWrap.appendChild(renderMessage(c)));
  el.querySelector('.post-body').appendChild(repliesWrap);

  // ✅ Only roots get a composer, and only if not deleted
  if (isRoot && !msg.is_deleted) {
    const composer = document.createElement('div');
    composer.className = 'composer';
    composer.hidden = false; // start hidden
    composer.innerHTML = `
      <div class="avatar" aria-hidden="true">${(state.user.name || 'YO').slice(0,3).toUpperCase()}</div>
      <div>
        <label class="sr-only">Write a reply</label>
        <textarea class="input" placeholder="Write a thoughtful reply…"></textarea>
        <div class="composer-actions">
          <button class="btn" onclick="cancelReply(this)">Cancel</button>
          <button class="btn primary" onclick="submitReply(this, '${msg.id}')">Post reply</button>
        </div>
      </div>`;
    el.querySelector('.post-body').appendChild(composer);
  }

  return el;
}


    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }

    /* ===== Network ===== */
function loadDisagreements() {
  const arr = window.DISAGREEMENTS || [];
  state.disagreements = arr.map(d => ({
    id: d.id,
    title: d.title,
    snippet_id: d["snippet-id"] ?? d.snippet_id,
    htmltext: d.htmltext
  }));
  if (!state.currentId && state.disagreements.length) {
    state.currentId = state.disagreements[0].id;
  }
  renderDisagreementsMenu();
  const first = state.disagreements.find(x => x.id === state.currentId);
    if (first) {
        $('#topic-title').textContent = first.title;
        $('#topic-description').innerHTML = first.htmltext || '';
    }

}

async function fetchLatestChat() {
  const payload = { username: state.user.name };
  const res = await fetch(CONFIG.GET_LATEST_CHAT_URL, {
    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
  });
  if (!res.ok) throw new Error('Failed to get latest chat');
  const data = await res.json();

  state.chatsByDisagreement = data.chats || {};
  state.previousLatestAt    = data.previousLatestAt || '';
  state.nowLatestAt         = data.nowLatestAt || '';
  state.oldestReturnedAt    = data.oldestReturnedAt || '';

  // ⬅️ Initialize per-disagreement baselines only if missing
  for (const d of state.disagreements) {
    const key = String(d.id);
    if (!state.lastSeenByDis[key]) {
      state.lastSeenByDis[key] = state.previousLatestAt || '';  // first-time baseline
    }
  }
  saveSeenToStorage();

  renderCurrentThread();
  updateDisagreementBadges();   // uses per-disagreement baselines now
}




    async function sendMessage({ disagreementId, parentId=null, content }) {
      const payload = { username: state.user.name, disagreementId, parentId, content };
      const res = await fetch(CONFIG.SUBMIT_CHAT_URL, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });
      if (!res.ok) { alert('Failed to send message'); return; }
      const data = await res.json();
      // Assume server returns updated structure compatible with fetchLatestChat
      if (data?.chats) {
        state.chatsByDisagreement = data.chats;
      } else {
        await fetchLatestChat();
      }
      renderCurrentThread();
    }

    async function deleteMessage(id) {
      const payload = { username: state.user.name, messageId: id };
      const res = await fetch(CONFIG.DELETE_CHAT_URL, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });
      if (!res.ok) { alert('Delete failed'); return; }
      await fetchLatestChat();
    }

    // Button handlers exposed globally
    window.vote = function(el, delta) {
      const post = el.closest('.post');
      const up = post.querySelector('[data-up]');
      const down = post.querySelector('[data-down]');
      const upN = parseInt(up?.textContent || '0', 10);
      const downN = parseInt(down?.textContent || '0', 10);
      if (delta > 0) up.textContent = upN + 1; else down.textContent = downN + 1;
    }
    window.toggleReply = function(btn) {
      const post = btn.closest('.post');
      const composer = post.querySelector('.composer');
      if (composer) composer.hidden = !composer.hidden;
    }
    window.cancelReply = function(el) {
      const card = el.closest('.composer');
      const ta = card.querySelector('textarea');
      ta.value = '';
      card.hidden = true;
    }
    window.submitReply = function(btn, parentId) {
      const composer = btn.closest('.composer');
      const text = composer.querySelector('textarea').value.trim();
      if (!text) return;
      sendMessage({ disagreementId: state.currentId, parentId, content: text });
    }
    window.requestDelete = function(id) {
      if (confirm('Delete your message? It will appear as [message deleted] but replies remain.')) deleteMessage(id);
    }

    // Root composer
    function bindRootComposer() {
      $('#post-root').addEventListener('click', () => {
        const ta = $('#new-opinion');
        const text = ta.value.trim();
        if (!text) return;
        sendMessage({ disagreementId: state.currentId, parentId: null, content: text });
        ta.value = '';
      });
    }

async function init() {
  checkLogin();
  $('#you-avatar').textContent = (state.user.name || 'YOU').slice(0,3).toUpperCase();

  loadSeenFromStorage();          // ⬅️ load persisted per-thread baselines first
  bindRootComposer();

  await loadDisagreements();
  if (!state.currentId && state.disagreements.length) {
    state.currentId = state.disagreements[0].id;
  }
  // mark we opened the initial tab
  state.currentOpenedAt = new Date().toISOString();

  await fetchLatestChat().catch(console.error);

  if (state.pollHandle) clearInterval(state.pollHandle);
  state.pollHandle = setInterval(() => fetchLatestChat().catch(console.error), CONFIG.POLL_MS);
}


    document.addEventListener('DOMContentLoaded', init);
  </script>


<script>
async function vote(el, delta) {
  const post = el.closest('.post');
  const messageId = post?.dataset?.id;
  if (!messageId) return;

  try {
    // Send to server
    const res = await fetch('https://codecomprehensibility.site/vote_chat', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        username: state.user.name, // already set from session/localStorage
        messageId,
        delta // +1 for like, -1 for dislike
      })
    });

    if (!res.ok) throw new Error('Vote failed');

    //re-pull full chat
    await fetchLatestChat();

  } catch (e) {
    console.error(e);
    alert('Could not register your vote.');
  }
}

</script>

<script>
window.toggleReply = function (btn) {
  const post = btn.closest('.post');
  if (!post) return;

  // Close other open composers
  document.querySelectorAll('.composer:not([hidden])').forEach(c => {
    if (!post.contains(c)) c.hidden = true;
  });

  const composer = post.querySelector('.composer');
  if (!composer) return;

  composer.hidden = !composer.hidden;

  if (!composer.hidden) {
    const ta = composer.querySelector('textarea');
    // Put cursor at end
    if (ta) {
      ta.focus();
      ta.selectionStart = ta.value.length;
      ta.selectionEnd = ta.value.length;
    }
  }
};

window.cancelReply = function (el) {
  const composer = el.closest('.composer');
  if (!composer) return;
  const ta = composer.querySelector('textarea');
  if (ta) ta.value = '';
  composer.hidden = true;
};


</script>

<script>
//     function isNewForUser(iso) {
//   if (!iso || !state.previousLatestAt) return false;
//   const msgTime = new Date(iso).getTime();
//   const prevLatest = new Date(state.previousLatestAt).getTime();
//   console.log("NEW NEW", !isNaN(msgTime) && !isNaN(prevLatest) && msgTime > prevLatest);
//   return !isNaN(msgTime) && !isNaN(prevLatest) && msgTime > prevLatest;
// }

</script>

<script>
function isNewForUser(iso){
  if(!iso || !state.previousLatestAt) return false;
  const mt = new Date(iso).getTime();
  const pt = new Date(state.previousLatestAt).getTime();
  return !isNaN(mt) && !isNaN(pt) && mt > pt;
}

/** Update number badges on the disagreement menu */
function updateDisagreementBadges(){
  const menu = document.getElementById('disagreements-menu');
  if(!menu) return;

  // Clear old badges
  menu.querySelectorAll('.menu-badge').forEach(b => b.remove());

  const chats = state.chatsByDisagreement || {};
  for (const [id, list] of Object.entries(chats)) {
    const btn = menu.querySelector(`.chip[data-id="${id}"]`);
    if (!btn) continue;

    let count = 0;
    const baseline = (String(id) === String(state.currentId) && state.currentOpenedAt)
      ? state.currentOpenedAt
      : (state.lastSeenByDis[String(id)] || state.previousLatestAt || '');

    if (baseline) {
      const bt = new Date(baseline).getTime();
      for (const m of (list || [])) {
        if (!m || m.is_deleted) continue;
        const mt = new Date(m.createdAt).getTime();
        if (!isNaN(mt) && mt > bt) count++;
      }
    }

    if (count > 0) {
      const badge = document.createElement('span');
      badge.className = 'menu-badge';
      badge.textContent = count > 99 ? '99+' : String(count);
      btn.appendChild(badge);
      btn.setAttribute('aria-label', `${btn.textContent.trim()} (${badge.textContent} new)`);
    } else {
      btn.removeAttribute('aria-label');
    }
  }
}


</script>

<script>
    function seenStorageKey(){
  const u = (state.user.name || 'anon').trim().toLowerCase();
  return `chat_seen_${u}`;
}
function loadSeenFromStorage(){
  try {
    const raw = localStorage.getItem(seenStorageKey());
    if (raw) state.lastSeenByDis = JSON.parse(raw) || {};
  } catch {}
}
function saveSeenToStorage(){
  try {
    localStorage.setItem(seenStorageKey(), JSON.stringify(state.lastSeenByDis || {}));
  } catch {}
}

</script>

<script>
    function isNewForUserIn(disagreementId, iso){
  if (!iso) return false;
  // If it's the current thread, use open time; else, use that thread's lastSeen baseline
  let baseline = '';
  if (String(disagreementId) === String(state.currentId) && state.currentOpenedAt) {
    baseline = state.currentOpenedAt;
  } else {
    baseline = state.lastSeenByDis[String(disagreementId)] || state.previousLatestAt || '';
  }
  if (!baseline) return false;
  const mt = new Date(iso).getTime();
  const bt = new Date(baseline).getTime();
  return !isNaN(mt) && !isNaN(bt) && mt > bt;
}

</script>

</body>
</html>
