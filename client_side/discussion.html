<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Threaded Opinions — Modern Chat Layout</title>
    <style>
        :root {
            --bg: #0b0c10;
            --panel: #151821;
            --panel-2: #10131a;
            --text: #e6e9ef;
            --muted: #a3aab9;
            --border: #232735;
            --primary: #7c5cff;
            --primary-2: #a590ff;
            --success: #22c55e;
            --danger: #ef4444;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35);
            --radius: 16px;
            --radius-sm: 12px;
            --radius-xs: 10px;
        }

        @media (prefers-color-scheme: light) {
            :root {
                --bg: #f6f7fb;
                --panel: #ffffff;
                --panel-2: #fbfbfe;
                --text: #0b1020;
                --muted: #606a80;
                --border: #e6e8ee;
                --shadow: 0 10px 30px rgba(9, 12, 22, .08);
            }
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background: radial-gradient(1200px 700px at 80% -200px, rgba(124, 92, 255, .18), transparent 60%),
                radial-gradient(1000px 500px at -200px 80%, rgba(79, 209, 197, .18), transparent 60%),
                var(--bg);
            line-height: 1.5;
        }

        /* Layout */
        .shell {
            max-width: 1100px;
            margin: min(6vh, 48px) auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 18px;
        }

        .topic-card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 18px 18px 2px 18px;
            position: sticky;
            top: 10px;
            z-index: 1;
        }

        .topic-heading {
            display: flex;
            align-items: start;
            gap: 14px;
        }

        .topic-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: grid;
            place-items: center;
            background: linear-gradient(145deg, rgba(124, 92, 255, .25), rgba(124, 92, 255, .05));
            border: 1px solid var(--border);
            flex: 0 0 auto;
        }

        .topic-title {
            margin: 0;
            font-size: clamp(22px, 2.5vw, 28px);
            letter-spacing: -0.01em;
        }

        .topic-meta {
            margin-top: 4px;
            color: var(--muted);
            font-size: 14px;
        }

        .toolbar {
            margin-top: 14px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        }

        .toolbar .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .chip {
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text);
            padding: 8px 12px;
            border-radius: 999px;
            font-size: 14px;
            cursor: pointer;
        }

        .select {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text);
            font-size: 14px;
            cursor: pointer;
        }

        .list-card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 12px;
        }

        /* Post item */
        .post {
            display: grid;
            grid-template-columns: 48px 1fr;
            gap: 12px;
            padding: 5px;
            border-radius: var(--radius-sm);
            border: 1px solid transparent;
            transition: border-color .2s ease, background .2s ease;
        }

        .post+.post {
            margin-top: 6px;
        }

        .post:hover {
            border-color: var(--border);
            background: rgba(124, 92, 255, .03);
        }

        .avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(145deg, #d1d5db, #9ca3af);
            display: grid;
            place-items: center;
            color: #0b0c10;
            font-weight: 700;
            user-select: none;
        }

        .post-body {
            min-width: 0;
        }

        .post-head {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .name {
            font-weight: 700;
        }

        .badge {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            color: var(--muted);
        }

        .time {
            color: var(--muted);
            font-size: 13px;
            margin-left: auto;
        }

        .content {
            margin-top: 6px;
            font-size: 15.5px;
        }

        .attachments {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .pill {
            font-size: 12px;
            border: 1px dashed var(--border);
            color: var(--muted);
            padding: 6px 10px;
            border-radius: 999px;
        }

        .post-actions {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
        }

        .btn.primary {
            border-color: transparent;
            background: linear-gradient(145deg, var(--primary), var(--primary-2));
            color: white;
        }

        .btn.ghost {
            opacity: .85;
        }

        .btn[aria-pressed="true"] {
            box-shadow: inset 0 0 0 2px currentColor;
        }

        .score {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: var(--muted);
            margin-left: 2px;
        }

        .score .up {
            color: var(--success);
        }

        .score .down {
            color: var(--danger);
        }

        /* Replies */
        .replies {
            margin-top: 10px;
            padding-left: 18px;
            border-left: 2px dashed var(--border);
            display: grid;
            gap: 8px;
        }

        /* Composer */
        .composer {
            margin-top: 12px;
            display: grid;
            grid-template-columns: 48px 1fr;
            gap: 12px;
            padding: 12px;
            border: 1px dashed var(--border);
            border-radius: var(--radius-sm);
            background: rgba(124, 92, 255, .05);
        }

        textarea.input {
            width: 100%;
            min-height: 64px;
            resize: vertical;
            background: var(--panel-2);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 12px;
            font: inherit;
        }

        .composer-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: flex-end;
        }

        /* Utilities */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 1px, 1px);
            border: 0;
        }

        .spacer {
            flex: 1;
        }

        /* Responsive tweaks */
        @media (max-width: 720px) {
            .topic-card {
                position: static;
            }

            .time {
                width: 100%;
                margin-left: 0;
            }

            .composer {
                grid-template-columns: 36px 1fr;
            }

            .avatar {
                width: 36px;
                height: 36px;
                font-size: 12px;
            }

            .post {
                grid-template-columns: 36px 1fr;
            }
        }

        .topic-description {
            margin-top: 10px;
            font-size: 14px;
            color: var(--muted);
        }

        .topic-description p {
            margin: 0;
        }

        .post.new-for-user {
            background: rgba(124, 92, 255, .08);
            border-color: var(--border);
        }

        /* tiny pill on disagreement buttons */
        .menu-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            padding: 2px 8px;
            min-width: 18px;
            font-size: 12px;
            line-height: 1;
            font-weight: 600;
            border-radius: 999px;
            color: #fff;
            background: linear-gradient(145deg, var(--primary), var(--primary-2));
        }


        /* Sticky bar wrapper */
        /* Sticky bar wrapper (keep as you had it) */
        #disagreements-bar {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--panel, var(--surface));
            border-bottom: 1px solid var(--border);
        }

        /* Use grid so items fill 100% width when few, but scroll when many */
        .disagreements-strip {
            display: grid;
            grid-auto-flow: column;
            /* lay chips in columns horizontally */
            grid-auto-columns: minmax(160px, 1fr);
            /* each chip at least 160px, otherwise stretch equally */
            overflow-x: auto;
            /* scroll when too many chips to fit */
            scrollbar-width: thin;
        }

        /* Glued rectangular segments */
        .disagreements-strip .chip {
            width: 100%;
            /* make each chip fill its grid column */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            /* room for title + badge */
            padding: 12px 14px;
            margin: 0;
            /* glue: no gaps */
            border: 0;
            border-right: 1px solid var(--border);
            /* vertical separators */
            border-radius: 0;
            /* square edges to glue seamlessly */
            background: var(--surface-2, #f7f7f8);
            color: var(--text);
            white-space: nowrap;
            cursor: pointer;
            text-align: center;
        }

        .disagreements-strip .chip:first-child {
            border-left: 1px solid var(--border);
        }

        .disagreements-strip .chip[aria-pressed="true"] {
            background: var(--surface-3, #ececf1);
            font-weight: 600;
        }

        /* Badge (if you use it) */
        .menu-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            padding: 2px 8px;
            min-width: 18px;
            font-size: 12px;
            line-height: 1;
            font-weight: 600;
            border-radius: 999px;
            color: #fff;
            background: linear-gradient(145deg, var(--primary), var(--primary-2));
        }

        /* Content offset so the sticky bar doesn't cover it */
        body.has-sticky-bar {
            --bar-h: 48px;
            padding-top: var(--bar-h);
        }

        /* Bar inner layout: Home button + glued strip */
        #disagreements-bar .bar-inner {
            display: flex;
            align-items: stretch;
            gap: 0;
        }

        /* Home chip: fixed-ish width so it stands apart */
        .home-chip {
            flex: 0 0 auto;
            width: 120px;
            /* adjust if you like */
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid var(--border);
            border-radius: 0;
            background: var(--surface-2, #f7f7f8);
        }

        .home-chip[aria-pressed="true"] {
            background: var(--surface-3, #ececf1);
            font-weight: 600;
        }

        /* Home cards grid */
        .home-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
        }

        .home-card {
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: pointer;
        }

        .home-card:hover {
            box-shadow: var(--shadow);
        }

        .home-card-title {
            font-weight: 700;
            font-size: 15px;
            line-height: 1.2;
        }

        .home-card-meta {
            color: var(--muted);
            font-size: 13px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* Reuse the same badge look for counts on cards */
        .card-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 2px 8px;
            min-width: 18px;
            line-height: 1;
            font-weight: 600;
            border-radius: 999px;
            color: #fff;
            font-size: 12px;
            background: linear-gradient(145deg, var(--primary), var(--primary-2));
        }

        /* When on Home view, hide the strip but keep the bar + Home button */
        body.is-home #disagreements-menu {
            display: none;
        }

        /* Mention chips in text */
        .mention {
            font-weight: 600;
            color: var(--primary);
            background: rgba(124, 92, 255, .12);
            border: 1px solid var(--border);
            padding: 0 6px;
            border-radius: 999px;
        }

        .mention.me {
            color: #fff;
            background: linear-gradient(145deg, var(--primary), var(--primary-2));
            border-color: transparent;
        }

        /* Suggestions dropdown */
        .mention-suggest {
            position: absolute;
            z-index: 2000;
            background: var(--panel);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 4px;
            min-width: 180px;
        }

        .mention-suggest button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 6px 8px;
            background: transparent;
            color: inherit;
            border: 0;
            border-radius: 8px;
            cursor: pointer;
        }

        .mention-suggest button:hover,
        .mention-suggest button[aria-selected="true"] {
            background: rgba(124, 92, 255, .12);
        }

        .sync-link {
            margin-left: 8px;
            font-size: 0.9em;
            color: var(--primary);
            cursor: pointer;
            text-decoration: underline;
            /* optional */
        }

        .sync-link:hover {
            text-decoration: none;
            /* optional hover effect */
            opacity: 0.8;
            /* subtle feedback */
        }
    </style>
</head>

<body>



    <div class="shell" role="application" aria-label="Threaded opinions" id="app">

<div id="instructions-box"
    style="background-color: #fff; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-top: 15px;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <h2 style="margin: 0;">Last round: Let’s chat and resolve disagreements, if possible.</h2>
        <button onclick="toggleInstructions()"
            style="padding: 6px 12px; font-size: 14px; border-radius: 5px; background-color: #ffffff; border: none; cursor: pointer; color: #222; border: solid;">Hide</button>
    </div>

    <div id="instructions-content" style="margin-top: 15px;">
        <ul style="margin: 0; padding-left: 20px;">
            <li>You are here because some disagreements remain about the positions of certain snippets in the rankings among experts.</li>
            <li>There are four forums below. Click on each, read the discussion point, and provide your answers.</li>
            <li>You can see the live rankings from all experts by clicking the <strong>Rankings</strong> button on the right-center of the screen.</li>
            <li>You will receive email notifications about new chat activity.</li>
            <li>You can tag other experts by typing "@" in the chat and selecting their name.</li>
            <li>For each discussion point, please discuss and try to reach a consensus on the ranking of snippets, if possible.</li>
            <li>Reaching agreement is not required. This is the final round, even if consensus cannot be reached. However, we encourage discussion to resolve disagreements that may still be solvable.</li>
        </ul>
    </div>

</div>


        <!-- Home grid (default visible) -->
        <section id="home-grid" class="list-card" aria-label="All disagreements">
            <h2 style="margin-bottom: 15px; font-size: 20px; font-weight: 600;">
                Discussion Forums on Ranking Disagreements
            </h2>
            <div id="home-cards" class="home-cards"></div>

        <!-- Top sticky disagreements bar -->
        <nav id="disagreements-bar" aria-label="Disagreements switcher">
            <div class="bar-inner">
                <button id="home-btn" class="chip home-chip" type="button" aria-pressed="true">🏠 Home</button>
                <button id="logout-btn" class="chip home-chip" type="button" onclick="logout()">🚪 Logout</button>
                <div id="disagreements-menu" class="disagreements-strip" role="tablist" aria-label="Disagreements">
                    <!-- chips injected by JS -->
                </div>
            </div>
        </nav>


        <div id="chat-view" hidden>
            <!-- Topic/Header + Disagreement Switcher -->
            <section class="topic-card" aria-labelledby="topic-title">
                <div class="topic-heading">
                    <div class="topic-icon" aria-hidden="true">💬</div>
                    <div>
                        <h1 id="topic-title" class="topic-title">Loading disagreements…</h1>
                        <div class="topic-meta" id="topic-meta">Single-subject thread • <span
                                id="opinion-count">0</span>
                            opinions • Last sync <span id="last-sync">—</span></div>
                    </div>
                </div>

                <div id="topic-description" class="topic-description"></div>

                <!-- <div class="toolbar" aria-label="Disagreements switcher">
            <div class="controls" id="disagreements-menu" style="overflow:auto; white-space:nowrap; padding-bottom:6px; width:100%">
            </div>
        </div> -->
            </section>

            <!-- Opinions List (dynamic) -->
            <section class="list-card" aria-live="polite">
                <div id="posts"></div>
            </section>

            <!-- New Opinion Composer (root-level) -->
            <section class="list-card" aria-label="Add new opinion">
                <div class="composer">
                    <div class="avatar" aria-hidden="true" id="you-avatar">YOU</div>
                    <div style="width:100%">
                        <label class="sr-only" for="new-opinion">Share your opinion</label>
                        <textarea id="new-opinion" class="input" placeholder="Share your opinion…"></textarea>
                        <div class="composer-actions">
                            <button class="btn" id="attach-btn" disabled>Attach</button>
                            <span class="spacer"></span>
                            <button class="btn primary" id="post-root">Post opinion</button>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <script src="js/disagreements.js"></script>

    <script>

        function firstChars(name, count = 20) {
            if (!name) return "";
            return name.slice(0, count);
        }

        /* ===== Auth helpers (provided) ===== */
        function isLoggedIn() {
            const name = sessionStorage.getItem('participantName') || localStorage.getItem('participantName');
            const order = sessionStorage.getItem('snippetOrder') || localStorage.getItem('snippetOrder');
            return name && order;
        }
        function checkLogin() {
            if (!isLoggedIn()) {
                alert('You must be logged in to access this page. Redirecting to the homepage.');
                window.location.href = 'https://codecomprehensibility.site/discussion-round.html';
            }
        }

        /* ===== Config ===== */
        const CONFIG = {
            DISAGREEMENTS_URL: 'js/disagreements.json',
            GET_LATEST_CHAT_URL: 'https://codecomprehensibility.site/get_latest_chat',
            SUBMIT_CHAT_URL: 'https://codecomprehensibility.site/submit_chat',   // TODO: confirm
            DELETE_CHAT_URL: 'https://codecomprehensibility.site/delete_chat',   // TODO: confirm
            POLL_MS: 120000
        };

        /* ===== App state ===== */
        const state = {
            user: {
                name: sessionStorage.getItem('username') || localStorage.getItem('username') || 'You'
            },
            disagreements: [],
            currentId: null,
            chatsByDisagreement: {},
            previousLatestAt: '',      // from server (do not mutate)
            nowLatestAt: '',
            oldestReturnedAt: '',
            lastSeenByDis: {},         // ⬅️ per-disagreement baseline
            view: 'home',
            currentOpenedAt: '',       // ⬅️ baseline for currently open disagreement (set on switch)
            currentBaseline: '',
            usernames: [],
            pollHandle: null
        };



        /* ===== Utility ===== */
        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        function fmtTime(iso) {
            if (!iso) return '';
            // Ensure string like "2025-08-14T16:03:25Z" or "...-04:00"
            // The Date ctor understands both and converts to the user's local tz for output.
            const d = new Date(iso);
            if (isNaN(d.getTime())) return ''; // safeguard
            // Use Intl to respect user locale + local time zone automatically
            return new Intl.DateTimeFormat(undefined, {
                year: 'numeric', month: 'short', day: '2-digit',
                hour: '2-digit', minute: '2-digit',
            }).format(d);
        }

        function currentHandle() {
            // prefer the short handle if you store it; fall back to display name
            const h = sessionStorage.getItem('username')
                || localStorage.getItem('username')
                || state.user.name
                || '';
            return (h || '').trim().toLowerCase();
        }

        function defaultBaselineISO(yearsAgo = 1) {
            const d = new Date();
            d.setFullYear(d.getFullYear() - yearsAgo);
            return d.toISOString(); // UTC ISO string
        }


        // Build a thread tree from flat messages
        function buildThread(messages) {
            const byId = new Map();
            const roots = [];
            messages.forEach(m => {
                m.children = [];
                byId.set(m.id, m);
            });
            messages.forEach(m => {
                if (m.parentId) {
                    const p = byId.get(m.parentId);
                    if (p) p.children.push(m); else roots.push(m); // orphan safeguard
                } else {
                    roots.push(m);
                }
            });
            // sort by time ascending within each level (server may already do)
            const sortRec = nodes => {
                nodes.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
                nodes.forEach(n => sortRec(n.children));
            };
            sortRec(roots);
            return roots;
        }

        // On boot, mark body so CSS adds top padding
        document.addEventListener('DOMContentLoaded', () => {
            document.body.classList.add('has-sticky-bar');
        });

        function renderDisagreementsMenu() {
            const menu = document.getElementById('disagreements-menu');
            if (!menu) {
                console.warn('🚫 renderDisagreementsMenu: #disagreements-menu not found');
                return;
            }
            menu.innerHTML = '';

            console.groupCollapsed('🧱 renderDisagreementsMenu');
            const ids = [];
            state.disagreements.forEach(d => {
                const id = String(d.id);            // ensure attribute is string
                ids.push(id);

                const btn = document.createElement('button');
                btn.className = 'chip';
                btn.type = 'button';
                btn.role = 'tab';
                btn.dataset.id = id;                // <button data-id="...">
                btn.setAttribute('aria-pressed', String(d.id === state.currentId));
                btn.textContent = firstChars(d.title);
                btn.onclick = () => openDisagreement(toId(d.id));
                menu.appendChild(btn);
            });
            console.log('chips rendered:', ids);
            console.log('chip elements count:', menu.querySelectorAll('.chip').length);
            console.groupEnd();

            updateDisagreementBadges();           // badges only after chips exist
        }




        function switchDisagreement(newId) {
            const prevId = state.currentId;
            const nowIso = new Date().toISOString();

            console.groupCollapsed('🔁 switchDisagreement');
            console.log('prevId:', prevId, '→ newId:', newId);

            if (prevId != null) {
                const stamp = new Date(Date.now() - 1000).toISOString();
                state.lastSeenByDis[String(prevId)] = stamp;
                console.log('marked previous as seen:', String(prevId), '→', stamp);
                saveSeenToStorage();
                pushSeenToServer();

            }

            state.currentId = toId(newId);
            state.currentOpenedAt = nowIso;
            console.log('currentOpenedAt set to:', nowIso);
            console.log('lastSeenByDis snapshot:', JSON.parse(JSON.stringify(state.lastSeenByDis)));
            console.groupEnd();

            document.querySelectorAll('#disagreements-menu .chip')
                .forEach(b => b.setAttribute('aria-pressed', String(b.dataset.id == newId)));

            const active = document.querySelector(`#disagreements-menu .chip[data-id="${newId}"]`);
            active?.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });

            const d = state.disagreements.find(x => String(x.id) === String(newId));
            if (d) {
                $('#topic-title').textContent = d.title;
                $('#topic-description').innerHTML = d.htmltext || '';
                $('#topic-meta').innerHTML = `Snippet ${d['snippet-id'] ?? d.snippet_id ?? '—'} • <span id="opinion-count">0</span> opinions • Last sync <span id="last-sync">—</span>`;
            }

            renderCurrentThread();
            updateDisagreementBadges();
        }




        function renderCurrentThread() {
            if (state.view !== 'chat' || state.currentId == null) return;
            const posts = $('#posts');
            posts.innerHTML = '';
            const msgs = state.chatsByDisagreement[state.currentId] || [];
            const thread = buildThread(msgs);
            $('#opinion-count').textContent = msgs.length;
            $('#last-sync').textContent = new Date().toLocaleTimeString();
            thread.forEach(node => posts.appendChild(renderMessage(node)));
        }

        function renderMessage(msg) {
            const el = document.createElement('article');
            el.className = 'post';
            el.dataset.id = msg.id;

            const isRoot = !msg.parentId; // only roots can be replied to
            const isNew = isNewForUserIn(state.currentId, msg);
            const newBadge = isNew
                ? `<span class="badge" style="border-color:transparent; background:linear-gradient(145deg,#ef4444,#dc2626); color:#fff;">NEW</span>`
                : '';




            el.innerHTML = `
    <div class="avatar" aria-hidden="true">${(msg.username || '?').slice(0, 2).toUpperCase()}</div>
    <div class="post-body">
      <div class="post-head">
        <span class="name">${msg.username || 'Unknown'}</span>
        ${newBadge}
        ${msg.role ? `<span class="badge">${msg.role}</span>` : ''}
        <time class="time" datetime="${msg.createdAt || ''}">${fmtTime(msg.createdAt)}</time>
      </div>
        <div class="content">
        ${msg.is_deleted ? '<em style="color:var(--muted)">[message deleted]</em>'
                    : linkMentions(escapeHtml(msg.content || ''))}
        </div>

      <div class="post-actions">
        <button class="btn" onclick="vote(this, 1)">👍</button>
        <button class="btn" onclick="vote(this, -1)">👎</button>
        <span class="score"><span class="up" data-up>${msg.up || 0}</span>/<span class="down" data-down>${msg.down || 0}</span></span>
        <span class="spacer"></span>
        ${
                // ✅ show Reply ONLY for root, non-deleted
                (isRoot && !msg.is_deleted)
                    ? `<button class="btn ghost" onclick="toggleReply(this)">↩︎ Reply</button>`
                    : ``
                }
        ${
                // keep delete for the author if not deleted
                (msg.username === state.user.name && !msg.is_deleted)
                    ? `<button class="btn ghost hidden" onclick="requestDelete('${msg.id}')" style="display: none;">🗑 Delete</button>`
                    : ``
                }
        <button class="btn ghost" style="display: none;">⋯</button>
      </div>
    </div>
  `;

            // Replies container (always render so children show under any message)
            const repliesWrap = document.createElement('div');
            repliesWrap.className = 'replies';
            (msg.children || []).forEach(c => repliesWrap.appendChild(renderMessage(c)));
            el.querySelector('.post-body').appendChild(repliesWrap);

            // ✅ Only roots get a composer, and only if not deleted
            if (isRoot && !msg.is_deleted) {
                const composer = document.createElement('div');
                composer.className = 'composer';
                composer.hidden = false; // start hidden
                composer.innerHTML = `
      <div class="avatar" aria-hidden="true">${(state.user.name || 'YO').slice(0, 3).toUpperCase()}</div>
      <div>
        <label class="sr-only">Write a reply</label>
        <textarea class="input" placeholder="Write a reply…"></textarea>
        <div class="composer-actions">
          <button class="btn" onclick="cancelReply(this)">Cancel</button>
          <button class="btn primary" onclick="submitReply(this, '${msg.id}')">Post reply</button>
        </div>
      </div>`;
                el.querySelector('.post-body').appendChild(composer);
                // enable @ on this reply textarea
                const ta = composer.querySelector('textarea.input');
                if (ta) enableMentions(ta);
            }

            return el;
        }


        function escapeHtml(s) {
            return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' }[c]));
        }

        /* ===== Network ===== */
        function loadDisagreements() {
            const arr = window.DISAGREEMENTS || [];
            state.disagreements = arr.map(d => ({
                id: d.id,
                title: d.title,
                snippet_id: d["snippet-id"] ?? d.snippet_id,
                htmltext: d.htmltext
            }));

            // ❌ Do NOT set state.currentId here
            // if (!state.currentId && state.disagreements.length) {
            //   state.currentId = state.disagreements[0].id;
            // }

            renderDisagreementsMenu();

            // ❌ Do NOT prime topic header here; we are on Home
            // const first = state.disagreements.find(x => x.id === state.currentId);
            // if (first) {
            //   $('#topic-title').textContent = first.title;
            //   $('#topic-description').innerHTML = first.htmltext || '';
            // }
        }


        async function fetchLatestChat() {
            const res = await fetch(CONFIG.GET_LATEST_CHAT_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username: currentHandle() || state.user.name })
            });
            if (!res.ok) throw new Error('Failed to get latest chat');

            const data = await res.json();

            // 1) Normalize chats
            const normalized = {};
            for (const [k, v] of Object.entries(data.chats || {})) normalized[String(k)] = v || [];
            state.chatsByDisagreement = normalized;

            // 2) Meta
            state.previousLatestAt = data.previousLatestAt || '';
            state.nowLatestAt = data.nowLatestAt || '';
            state.oldestReturnedAt = data.oldestReturnedAt || '';

            // 3) Mentions allowlist
            state.usernames = Array.isArray(data.usernames)
                ? [...new Set(data.usernames.map(s => (s || '').toLowerCase()))]
                : [];

            // 4) Ensure we have a local map (so merge works)
            state.lastSeenByDis ||= {};

            // 5) 🔑 Merge the server’s per-disagreement last-seen (newer wins)
            //    (This is what you asked about.)
            if (data.lastSeenByDis) {
                mergeServerSeen(data.lastSeenByDis);
            }

            // 6) Initialize any missing disagreements to a fallback baseline
            const fallback = state.previousLatestAt || defaultBaselineISO(1);
            for (const d of state.disagreements) {
                const key = String(d.id);
                if (!state.lastSeenByDis[key]) state.lastSeenByDis[key] = fallback;
            }
            saveSeenToStorage();

            // 7) Paint after state is consistent
            if (state.view === 'chat') renderCurrentThread();
            updateDisagreementBadges();
            if (state.view === 'home') renderHomeGrid();
        }




        async function sendMessage({ disagreementId, parentId = null, content }) {
            const mentions = extractMentions(content, state.usernames);
            const payload = { username: state.user.name, disagreementId, parentId, content, mentions };
            const res = await fetch(CONFIG.SUBMIT_CHAT_URL, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            if (!res.ok) { alert('Failed to send message'); return; }
            const data = await res.json();
            state.chatsByDisagreement = data.chats || state.chatsByDisagreement;
            await fetchLatestChat().catch(() => { });
            renderCurrentThread();
        }


        async function deleteMessage(id) {
            const payload = { username: state.user.name, messageId: id };
            const res = await fetch(CONFIG.DELETE_CHAT_URL, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            if (!res.ok) { alert('Delete failed'); return; }
            await fetchLatestChat();
        }

        // Button handlers exposed globally
        window.vote = function (el, delta) {
            const post = el.closest('.post');
            const up = post.querySelector('[data-up]');
            const down = post.querySelector('[data-down]');
            const upN = parseInt(up?.textContent || '0', 10);
            const downN = parseInt(down?.textContent || '0', 10);
            if (delta > 0) up.textContent = upN + 1; else down.textContent = downN + 1;
        }
        window.toggleReply = function (btn) {
            const post = btn.closest('.post');
            const composer = post.querySelector('.composer');
            if (composer) composer.hidden = !composer.hidden;
        }
        window.cancelReply = function (el) {
            const card = el.closest('.composer');
            const ta = card.querySelector('textarea');
            ta.value = '';
            card.hidden = true;
        }
        window.submitReply = function (btn, parentId) {
            const composer = btn.closest('.composer');
            const text = composer.querySelector('textarea').value.trim();
            if (!text) return;
            sendMessage({ disagreementId: state.currentId, parentId, content: text });
        }
        window.requestDelete = function (id) {
            if (confirm('Delete your message? It will appear as [message deleted] but replies remain.')) deleteMessage(id);
        }

        // Root composer
        function bindRootComposer() {
            const ta = $('#new-opinion');
            if (ta) enableMentions(ta); // ⬅️ enable @ for root
            $('#post-root').addEventListener('click', () => {
                const text = ta.value.trim();
                if (!text) return;
                sendMessage({ disagreementId: state.currentId, parentId: null, content: text });
                ta.value = '';
            });
        }


        async function init() {
            checkLogin();
            document.body.classList.add('has-sticky-bar');
            $('#you-avatar').textContent = (state.user.name || 'YOU').slice(0, 3).toUpperCase();

            loadSeenFromStorage();          // ⬅️ you already have this helper
            bindRootComposer();

            await loadDisagreements();      // builds chip titles
            renderDisagreementsMenu();      // create chips early (so badges can attach)

            // Do NOT set state.currentId here; we start on Home
            await fetchLatestChat().catch(console.error);

            // First paint of Home grid
            renderHomeGrid();
            showView('home');               // ⬅️ default to Home

            if (state.pollHandle) clearInterval(state.pollHandle);
            state.pollHandle = setInterval(() => {
                fetchLatestChat().then(() => {
                    if (state.view === 'home') renderHomeGrid(); // refresh counts on cards
                }).catch(console.error);
            }, CONFIG.POLL_MS);
        }



        document.addEventListener('DOMContentLoaded', init);
    </script>


    <script>
        async function vote(el, delta) {
            const post = el.closest('.post');
            const messageId = post?.dataset?.id;
            if (!messageId) return;

            try {
                // Send to server
                const res = await fetch('https://codecomprehensibility.site/vote_chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: state.user.name, // already set from session/localStorage
                        messageId,
                        delta // +1 for like, -1 for dislike
                    })
                });

                if (!res.ok) throw new Error('Vote failed');

                //re-pull full chat
                await fetchLatestChat();

            } catch (e) {
                console.error(e);
                alert('Could not register your vote.');
            }
        }

    </script>

    <script>
        window.toggleReply = function (btn) {
            const post = btn.closest('.post');
            if (!post) return;

            // Close other open composers
            document.querySelectorAll('.composer:not([hidden])').forEach(c => {
                if (!post.contains(c)) c.hidden = true;
            });

            const composer = post.querySelector('.composer');
            if (!composer) return;

            composer.hidden = !composer.hidden;

            if (!composer.hidden) {
                const ta = composer.querySelector('textarea');
                // Put cursor at end
                if (ta) {
                    ta.focus();
                    ta.selectionStart = ta.value.length;
                    ta.selectionEnd = ta.value.length;
                }
            }
        };

        window.cancelReply = function (el) {
            const composer = el.closest('.composer');
            if (!composer) return;
            const ta = composer.querySelector('textarea');
            if (ta) ta.value = '';
            composer.hidden = true;
        };


    </script>

    <script>
        //     function isNewForUser(iso) {
        //   if (!iso || !state.previousLatestAt) return false;
        //   const msgTime = new Date(iso).getTime();
        //   const prevLatest = new Date(state.previousLatestAt).getTime();
        //   console.log("NEW NEW", !isNaN(msgTime) && !isNaN(prevLatest) && msgTime > prevLatest);
        //   return !isNaN(msgTime) && !isNaN(prevLatest) && msgTime > prevLatest;
        // }

    </script>

    <script>
        function isNewForUser(iso) {
            if (!iso || !state.previousLatestAt) return false;
            const mt = new Date(iso).getTime();
            const pt = new Date(state.previousLatestAt).getTime();
            return !isNaN(mt) && !isNaN(pt) && mt > pt;
        }

        /** Update number badges on the disagreement menu */
        function updateDisagreementBadges() {
            const menu = document.getElementById('disagreements-menu');
            if (!menu) return;

            // Clear old
            menu.querySelectorAll('.menu-badge').forEach(b => b.remove());

            const chats = state.chatsByDisagreement || {};
            const me = currentHandle();

            for (const [id, list] of Object.entries(chats)) {
                const idStr = String(id);
                const btn = menu.querySelector(`.chip[data-id="${idStr}"]`);
                if (!btn) continue;

                const isActive = (state.view === 'chat' && idStr === String(state.currentId));
                const baseline = isActive
                    ? (state.currentBaseline || state.lastSeenByDis[idStr] || state.previousLatestAt || defaultBaselineISO(1))
                    : (state.lastSeenByDis[idStr] || state.previousLatestAt || defaultBaselineISO(1));

                let count = 0;
                if (baseline) {
                    const bt = new Date(baseline).getTime();
                    for (const m of (list || [])) {
                        if (!m || m.is_deleted) continue;
                        const author = (m.username || '').trim().toLowerCase();
                        if (author && author === me) continue; // don't count your own
                        const mt = new Date(m.createdAt).getTime();
                        if (!isNaN(mt) && mt > bt) count++;
                    }
                }

                if (count > 0) {
                    const badge = document.createElement('span');
                    badge.className = 'menu-badge';
                    badge.textContent = count > 99 ? '99+' : String(count);
                    btn.appendChild(badge);
                    btn.setAttribute('aria-label', `${btn.textContent.trim()} (${badge.textContent} new)`);
                } else {
                    btn.removeAttribute('aria-label');
                }
            }
        }






    </script>

    <script>
        function seenStorageKey() {
            const u = (state.user.name || 'anon').trim().toLowerCase();
            return `chat_seen_${u}`;
        }
        function loadSeenFromStorage() {
            try {
                const key = `chat_seen_${(state.user.name || 'anon').toLowerCase()}`;
                const raw = localStorage.getItem(key);
                if (raw) state.lastSeenByDis = JSON.parse(raw) || {};
                console.log('📦 loaded lastSeenByDis from storage:', state.lastSeenByDis);
            } catch (e) { console.warn('lastSeen load failed', e); }
        }

        function saveSeenToStorage() {
            try {
                localStorage.setItem(seenStorageKey(), JSON.stringify(state.lastSeenByDis || {}));
            } catch { }
        }

    </script>

    <script>
        function isNewForUserIn(disagreementId, msg) {
            if (!msg?.createdAt) return false;

            // Don't flag your own posts as NEW
            const author = (msg.username || '').trim().toLowerCase();
            if (author && author === currentHandle()) return false;

            const idStr = String(disagreementId);
            // While the active thread is open, use the captured baseline (last seen)
            const baseline =
                (state.view === 'chat' && idStr === String(state.currentId) && state.currentBaseline)
                    ? state.currentBaseline
                    : (state.lastSeenByDis[idStr] || state.previousLatestAt || defaultBaselineISO(1));

            const mt = new Date(msg.createdAt).getTime();
            const bt = new Date(baseline).getTime();
            return !isNaN(mt) && !isNaN(bt) && mt > bt;
        }



    </script>

    <script>
        window.addEventListener('beforeunload', () => {
            // Only stamp when the user is actually viewing a thread
            if (state.view === 'chat' && state.currentId != null) {
                state.lastSeenByDis[String(state.currentId)] = new Date().toISOString();
                saveSeenToStorage();
                pushSeenToServer();
            }
        });


    </script>

    <script>
        function showView(view) {
            state.view = view;
            const homeGrid = document.getElementById('home-grid');
            const chatView = document.getElementById('chat-view');
            const homeBtn = document.getElementById('home-btn');
            const strip = document.getElementById('disagreements-menu');

            const isHome = view === 'home';

            // toggle main panes
            homeGrid.hidden = !isHome;
            chatView.hidden = isHome;

            // mark pressed + body class (drives CSS)
            homeBtn?.setAttribute('aria-pressed', String(isHome));
            document.body.classList.toggle('is-home', isHome);

            // (optional) if you prefer JS instead of CSS: strip.hidden = isHome;

            // repaint Home cards when entering Home
            if (isHome) renderHomeGrid();
        }


        document.getElementById('home-btn')?.addEventListener('click', () => {
            if (state.view === 'chat' && state.currentId != null) {
                state.lastSeenByDis[String(state.currentId)] = new Date().toISOString();
                saveSeenToStorage();
            }
            showView('home');
        });

        function currentHandle() {
            const h = sessionStorage.getItem('username')
                || localStorage.getItem('username')
                || state.user.name || '';
            return (h || '').trim().toLowerCase();
        }

        function newCountForDisagreement(id) {
            const list = state.chatsByDisagreement?.[String(id)] || [];
            const me = currentHandle();

            // On Home, this will use lastSeen; in Chat for active id, it can use currentOpenedAt
            const useOpenBaseline = state.view === 'chat' && String(id) === String(state.currentId) && state.currentOpenedAt;
            const baseline = useOpenBaseline
                ? state.currentOpenedAt
                : (state.lastSeenByDis[String(id)] || state.previousLatestAt || defaultBaselineISO(1));

            if (!baseline) return 0;
            const bt = new Date(baseline).getTime();

            let count = 0;
            for (const m of list) {
                if (!m || m.is_deleted) continue;
                const author = (m.username || '').trim().toLowerCase();
                if (author && author === me) continue;
                const mt = new Date(m.createdAt).getTime();
                if (!isNaN(mt) && mt > bt) count++;
            }
            return count;
        }


        function renderHomeGrid() {
            const wrap = document.getElementById('home-cards');
            if (!wrap) return;
            wrap.innerHTML = '';

            state.disagreements.forEach(d => {
                const id = String(d.id);
                const count = newCountForDisagreement(id);

                const card = document.createElement('article');
                card.className = 'home-card';
                card.setAttribute('role', 'button');
                card.setAttribute('tabindex', '0');
                card.dataset.id = id;

                card.innerHTML = `
      <div class="home-card-title">${d.title}</div>
      <div class="home-card-meta">
        <span>Snippet ${d['snippet-id'] ?? d.snippet_id ?? '—'}</span>
        ${count > 0 ? `<span class="card-badge">${count > 99 ? '99+' : count}</span>` : ''}
      </div>
    `;

                card.addEventListener('click', () => openDisagreement(id));
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openDisagreement(id); }
                });
                wrap.appendChild(card);
            });
        }

        function openDisagreement(id) {
            // If a thread was open, stamp it as seen NOW before switching away
            if (state.currentId != null) {
                state.lastSeenByDis[String(state.currentId)] = new Date().toISOString();
                saveSeenToStorage();
                pushSeenToServer();
            }

            const idStr = String(id);
            const baseline = state.lastSeenByDis[idStr] || state.previousLatestAt || defaultBaselineISO(1);

            state.currentId = idStr;
            state.currentOpenedAt = new Date().toISOString(); // informational
            state.currentBaseline = baseline;                  // ⬅️ use last-seen while open

            // Show chat view first so renderCurrentThread doesn't early-return
            showView('chat');

            // Update topic header
            const d = state.disagreements.find(x => String(x.id) === idStr);
            if (d) {
                $('#topic-title').textContent = d.title;
                $('#topic-description').innerHTML = d.htmltext || '';
                $('#topic-meta').innerHTML =
                    `Snippet ${d['snippet-id'] ?? d.snippet_id ?? '—'} • <span id="opinion-count">0</span> opinions • Last sync <span id="last-sync">—</span>   <span id="sync-now" class="sync-link" onclick="syncNow()">Sync now</span>`;
            }

            // Update menu pressed state
            document.querySelectorAll('#disagreements-menu .chip')
                .forEach(b => b.setAttribute('aria-pressed', String(b.dataset.id == idStr)));

            // Paint
            renderCurrentThread();
            updateDisagreementBadges();
        }



    </script>

    <script>
        function toId(v) { return String(v); }

    </script>

    <script>
        //for adding username taggings
        function extractMentions(text, allowed = []) {
            // Only match at start or after whitespace; token = [a-z0-9_]+
            const re = /(^|\s)@([a-z0-9_]+)/gi;
            const out = new Set();
            let m;
            while ((m = re.exec(text)) !== null) {
                const handle = (m[2] || '').toLowerCase();
                if (allowed.length === 0 || allowed.includes(handle)) out.add(handle);
            }
            return [...out];
        }

        function linkMentions(text) {
            if (!text) return '';
            const me = currentHandle();
            // Replace only standalone-style mentions; don’t touch emails "a@b.com" (no preceding space)
            return text.replace(/(^|\s)@([a-z0-9_]+)/gi, (full, lead, h) => {
                const handle = h.toLowerCase();
                const cls = (handle === me) ? 'mention me' : 'mention';
                return `${lead}<span class="${cls}">@${h}</span>`;
            });
        }

    </script>

    <script>
        //username tagging in messages
        let mentionUI = { box: null, items: [], idx: -1, ta: null };

        function ensureSuggestBox() {
            if (mentionUI.box) return mentionUI.box;
            const div = document.createElement('div');
            div.className = 'mention-suggest';
            div.hidden = true;
            document.body.appendChild(div);
            mentionUI.box = div;
            return div;
        }

        function positionSuggestBox(ta) {
            // simple: place under the textarea’s bottom-left (no caret math)
            const r = ta.getBoundingClientRect();
            const top = r.bottom + window.scrollY + 4;
            const left = r.left + window.scrollX + 0;
            mentionUI.box.style.top = `${top}px`;
            mentionUI.box.style.left = `${left}px`;
            mentionUI.box.style.minWidth = `${Math.min(r.width, 280)}px`;
        }

        function openMentionSuggest(ta, query) {
            const opts = state.usernames
                .filter(u => u.startsWith((query || '').toLowerCase()))
                .slice(0, 8);
            const box = ensureSuggestBox();
            box.innerHTML = '';
            mentionUI.items = [];
            mentionUI.idx = -1;
            mentionUI.ta = ta;

            if (opts.length === 0) { box.hidden = true; return; }

            opts.forEach((u, i) => {
                const b = document.createElement('button');
                b.type = 'button';
                b.textContent = `@${u}`;
                b.setAttribute('aria-selected', 'false');
                b.addEventListener('click', () => applyMention(ta, u));
                box.appendChild(b);
                mentionUI.items.push(b);
            });

            positionSuggestBox(ta);
            box.hidden = false;
        }

        function closeMentionSuggest() {
            if (mentionUI.box) mentionUI.box.hidden = true;
            mentionUI.items = [];
            mentionUI.idx = -1;
            mentionUI.ta = null;
        }

        function moveMentionSel(delta) {
            if (!mentionUI.items.length) return;
            mentionUI.idx = (mentionUI.idx + delta + mentionUI.items.length) % mentionUI.items.length;
            mentionUI.items.forEach((b, i) => b.setAttribute('aria-selected', String(i === mentionUI.idx)));
        }

        function applyMention(ta, handle) {
            // replace the trailing "@query" token before caret with "@handle "
            const start = ta.selectionStart;
            const before = ta.value.slice(0, start);
            const after = ta.value.slice(start);

            const m = before.match(/(^|\s)@([a-z0-9_]*)$/i);
            if (!m) return closeMentionSuggest();

            const replaceFrom = start - (m[2] || '').length - 1; // include '@'
            const lead = m[1] || '';
            const newBefore = before.slice(0, replaceFrom) + lead + '@' + handle + ' ';
            ta.value = newBefore + after;

            const caret = newBefore.length;
            ta.focus();
            ta.setSelectionRange(caret, caret);

            closeMentionSuggest();
        }

        function enableMentions(ta) {
            if (!ta) return;
            ta.addEventListener('input', () => {
                const pos = ta.selectionStart;
                const before = ta.value.slice(0, pos);
                // Only trigger when token is at start or after whitespace
                const m = before.match(/(^|\s)@([a-z0-9_]*)$/i);
                if (m) {
                    const q = m[2] || '';
                    // don’t show for your own handle only when empty? we can still show all
                    openMentionSuggest(ta, q);
                } else {
                    closeMentionSuggest();
                }
            });
            ta.addEventListener('keydown', (e) => {
                if (mentionUI.box && !mentionUI.box.hidden) {
                    if (e.key === 'ArrowDown') { moveMentionSel(1); e.preventDefault(); }
                    else if (e.key === 'ArrowUp') { moveMentionSel(-1); e.preventDefault(); }
                    else if (e.key === 'Enter' || e.key === 'Tab') {
                        if (mentionUI.idx >= 0 && mentionUI.items[mentionUI.idx]) {
                            e.preventDefault();
                            const label = mentionUI.items[mentionUI.idx].textContent || '';
                            applyMention(ta, label.replace(/^@/, ''));
                        } else {
                            closeMentionSuggest();
                        }
                    } else if (e.key === 'Escape') {
                        closeMentionSuggest();
                    }
                }
            });
            ta.addEventListener('blur', () => {
                // delay so click can register
                setTimeout(closeMentionSuggest, 150);
            });
        }

    </script>

    <script>
        function logout() {
            pushSeenToServer();
            sessionStorage.clear();
            localStorage.clear();


            // Clear all cookies
            document.cookie.split(";").forEach(cookie => {
                const name = cookie.split("=")[0].trim();
                document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
            });

            window.location.href = 'discussion-round.html';
        }
    </script>

    <script>
        async function pushSeenToServer() {
            const payload = {
                username: currentHandle() || (state.user.name || '').toLowerCase(),
                seen: state.lastSeenByDis || {}
            };
            try {
                const res = await fetch('https://codecomprehensibility.site/set_last_seen_disagreement', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) throw new Error('pushSeenToServer failed');
                const data = await res.json();
                // Optional: reconcile with server-confirmed merged map
                if (data && data.perDisagreement) {
                    mergeServerSeen(data.perDisagreement);
                }
            } catch (e) {
                console.error(e);
            }
        }


        function mergeServerSeen(serverMap) {
            if (!serverMap || typeof serverMap !== 'object') return;

            const local = state.lastSeenByDis || {};
            const time = (iso) => {
                const t = new Date(iso).getTime();
                return Number.isFinite(t) ? t : 0;
            };

            let changed = false;
            for (const [id, iso] of Object.entries(serverMap)) {
                const sid = String(id);
                const sIso = String(iso || '');
                if (!sIso) continue;

                const lt = time(local[sid]);
                const rt = time(sIso);
                if (rt > lt) {
                    local[sid] = sIso;
                    changed = true;
                }
            }

            if (changed) {
                state.lastSeenByDis = local;
                saveSeenToStorage();
                // Refresh any UI elements that depend on these baselines
                if (state.view === 'chat') renderCurrentThread();
                updateDisagreementBadges();
                if (state.view === 'home') renderHomeGrid();
            }
        }

    </script>

    <script>
        function syncNow() {
            location.reload();
        }



    </script>


    <script>
        function toggleInstructions() {
            const content = document.getElementById("instructions-content");
            const button = event.target;
        
            if (content.style.display === "none") {
                content.style.display = "block";
                button.textContent = "Hide";
            } else {
                content.style.display = "none";
                button.textContent = "Show";
            }
        }
    </script>
</body>

</html>