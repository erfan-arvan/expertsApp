<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Delphi Study Feedback Summary</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 40px;
      background-color: #f4f4f4;
      color: #333;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    .snippet, .phase-section, .reasoning-box {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 25px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .participant {
      background: #f9f9f9;
      border-left: 4px solid #aaa;
      padding: 10px;
      margin-bottom: 10px;
    }
    .participant h4 {
      margin-top: 0;
    }
    .label {
      font-weight: bold;
    }
    table.rank-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    table.rank-table th, table.rank-table td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }
    .reasoning-box p {
      margin-bottom: 10px;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      box-shadow: 0 0 10px #4CAF50;
      animation: glowPulse 1.5s infinite alternate;
    }

    #modal-code {
  background-color: #2d2d2d;
  color: #ccc;
  padding: 20px;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  overflow-x: auto;
  font-family: 'Courier New', Courier, monospace;
  font-size: 15px;
  line-height: 1.5;
}

.light-mode #modal-code {
  background-color: #f0f0f0;
  color: #333;
}
.code-container {
  display: grid;
  grid-template-columns: auto 1fr;
  background-color: inherit;
  color: inherit;
  font-family: 'Courier New', Courier, monospace;
  font-size: 15px;
  line-height: 1.5;
  padding: 20px;
  overflow-x: auto;
}

.line-numbers {
  text-align: right;
  padding-right: 10px;
  user-select: none;
  color: #888;
}

.code-content {
  white-space: pre;
}

#code {
  background-color: #2d2d2d;
  color: #ccc;
  padding: 20px;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  overflow-x: auto;
  font-family: 'Courier New', Courier, monospace;
  font-size: 15px;
  line-height: 1.5;
}

.light-mode #code {
  background-color: #f0f0f0;
  color: #333;
}
/* LIGHT MODE styles */
.keyword     { color: #0000ff; font-weight: bold; }
.type        { color: #007070; }
.function    { color: #7928a1; font-weight: bold; }
.literal     { color: #009999; }
.string      { color: #a31515; }
.comment     { color: #6a9955; font-style: italic; }
.number      { color: #098658; }

/* DARK MODE overrides */
.dark-mode .keyword  { color: #82aaff; }
.dark-mode .type     { color: #89ddff; }
.dark-mode .function { color: #c792ea; }
.dark-mode .literal  { color: #ffcb6b; }
.dark-mode .string   { color: #c3e88d; }
.dark-mode .comment  { color: #7f848e; }
.dark-mode .number   { color: #f78c6c; }

a {
    color: #4CAF50;
    text-decoration: none;
}
a:hover {
    text-decoration: underline;
}

.sticky-menu {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: #ffffff;
  padding: 10px 0;
  border-top: 1px solid #ddd;
  display: flex;
  justify-content: center;
  gap: 12px;
  z-index: 1000;
  box-shadow: 0 -2px 6px rgba(0,0,0,0.06);
}

.sticky-menu button {
  background: #ffffff;
  color: #333;
  font-weight: 500;
  border: 1px solid #ccc;
  border-radius: 6px;
  padding: 8px 14px;
  cursor: pointer;
  transition: background 0.2s, box-shadow 0.2s;
}

.sticky-menu button:hover {
  background: #f3f3f3;
  box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}


    .participant-section {
      margin-bottom: 10px;
    }

    .ranking-row {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .ranking-labels {
      display: flex;
      gap: 10px;
      margin-bottom: 5px;
    }

    .ranking-label {
      flex: 1;
      text-align: center;
      font-weight: bold;
      color: #009999;
    }

    .ranking-slot {
      flex: 1;
      min-height: 100px;
      border: 2px dashed #4CAF50;
      background-color: #e8f5e9;
      border-radius: 6px;
      padding: 10px;
    }

    .ranking-slot button {
      display: block;
      width: 100%;
      margin: 5px 0;
      padding: 6px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }

    .ranking-slot button:hover {
      background-color: #45a049;
      position: relative;
    }

    .ranking-label:last-child {
      color: red;
    }

    .snippet-1 { background-color: #4CAF50; color: white; } /* Green */
    .snippet-2 { background-color: #2196F3; color: white; } /* Blue */
    .snippet-3 { background-color: #f44336; color: white; } /* Red */
    .snippet-4 { background-color: #FF9800; color: white; } /* Orange */
    .snippet-5 { background-color: #9C27B0; color: white; } /* Purple */
    .snippet-6 { background-color: #3F51B5; color: white; } /* Indigo */
    .snippet-7 { background-color: #009688; color: white; } /* Teal */
    .snippet-8 { background-color: #795548; color: white; } /* Brown */

    button.snippet-1 { background-color: #4CAF50; color: white; }
    button.snippet-2 { background-color: #2196F3; color: white; }
    button.snippet-3 { background-color: #f44336; color: white; }
    button.snippet-4 { background-color: #FF9800; color: white; }
    button.snippet-5 { background-color: #9C27B0; color: white; }
    button.snippet-6 { background-color: #3F51B5; color: white; }
    button.snippet-7 { background-color: #009688; color: white; }
    button.snippet-8 { background-color: #795548; color: white; }


.reasoning-point {
  position: absolute;
  width: 5px;
  height: 5px;
  background: white;
  border: 2px solid black;
  border-radius: 50%;
  cursor: pointer;
  z-index: 10;
  transition: transform 0.2s ease;
}

.reasoning-point:hover {
  transform: scale(1.2);
}

.tooltip-box {
  position: absolute;
  background-color: #333;
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 14px;
  max-width: 260px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  display: none;
  z-index: 99;
}

.reasoning-container {
  position: relative;
}

/* Show tooltip on hover */
.reasoning-point:hover + .tooltip-box {
  display: block;
}

.snippet-box {
  background: #f9f9f9;
  border: 1px solid #ccc;
  border-radius: 6px;
  padding: 10px;
  margin-bottom: 10px;
  font-family: 'Courier New', monospace;
  white-space: pre-wrap;
  overflow-x: auto;
}

.code-content {
  background-color: #f0f0f0;
  padding: 10px;
  border-radius: 4px;
}

  </style>
</head>
<body>

  <h1>Delphi Study Pilot Feedback</h1>

  <div class="phase-section">
    <h2>Phase 1: Snippet Summaries and Comprehensibility</h2>
  
    <!-- Snippet 1 -->
    <div class="snippet">
      <h3>Snippet 1</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> This method takes a project name and validates it based on several criteria.</p>
        <p><strong>Comprehensibility:</strong> Clear method/final variable names make it easier to understand. Also, the clear logic separation of the conditional statements makes it easier to follow.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Checks that the project name is valid: it is not null, does not start with ., is within length, is alphanumeric, and contains allowed characters.</p>
        <p><strong>Comprehensibility:</strong> This one is easy to understand: the logic is simple and the identifiers helped me understand what the method is doing.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> This is a string validation method implementing the follow rules:<br>
        – the input must be nonnull<br>
        – the input must not start with a dot<br>
        – the input must not be the empty string<br>
        – the input must be shorter than or equal to the MAX_NAME_LENGTH constant<br>
        – each character must be a letter/digit or in VALID_NAME_SET</p>
        <p><strong>Comprehensibility:</strong> The method is a straightforward set of tests against the string. These kinds of tests are common in validation logic. The name `VALID_NAME_EST` and the method name, combined with the string operations being performed, make the purpose obvious. The method uses simple string conditions to check most of the properties; the only ones that are more complex are the character properties, which are contained in a simple loop. So, structurally, the method is also easy to understand
        </p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong>   This method, isValidProjectName, checks whether a given string is a valid project name based on several criteria:<br><br>
            It must not be null.<br>
            It must not start with a dot (.).<br>
            Its length must be between 1 and a maximum defined by MAX_NAME_LENGTH.<br>
            Every character in the name must be either a letter, digit, or a member of the VALID_NAME_SET.<br><br>
            If all these conditions are met, it returns true; otherwise, it returns false.</p>
        <p><strong>Comprehensibility:</strong> This snippet is easy to understand due to the following factors:<br><br>
            Descriptive naming: The method name isValidProjectName clearly conveys its purpose.<br>
            Straightforward logic: The checks are simple, sequential, and follow an intuitive order of validation (null check → format check → length check → character check).<br>
            Readable structure: Each condition is isolated in a separate if block, avoiding nesting and making the logic easy to follow.<br>
            Familiar constructs: Uses standard Java constructs and well-known classes like Character.</p>
      </div>
    </div>
  
    <!-- Snippet 2 -->
    <div class="snippet">
      <h3>Snippet 2</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> This method takes a URI and checks if it is a local reference or not.</p>
        <p><strong>Comprehensibility:</strong> Meaningful method name (including clear internal method invocation names) and a switch statement with simple logic make it easier to understand.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> It checks that the given URI is remote. If the URI is a file system path, does not have a scheme, or the scheme is file/jar, it is not remote; otherwise it is.</p>
        <p><strong>Comprehensibility:</strong> Easy to understand: easy logic, identifiers helped. It's harder than Snippet 1 due to unclear isFilesystemPath and URI scheme.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> This method validates a URI according to a set of rules. The URI is valid (and the method returns true) iff:\n* the uri isn't a filesystem path\n* the uri has a nonnull `Scheme`\n* the uri's scheme is something other than \"file\" or \"jar\"\n\nBased on the method name, I think that means that the goal of the method is to check if the URI requires network access to reach.</p>
        <p><strong>Comprehensibility:</strong> It's pretty easy to understand. `isRemote` and `isFilesystemPath` have pretty obvious meanings, and the `scheme` check later on is also simple enough. There are some subtleties here (how do we know that \"jar\" and \"file\" are the only URI schemes that are not remote? I think that's domain knowledge...), but overall the purpose is clear and easy to understand from the code's structure</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong>   The method isRemote determines whether a given URI refers to a remote resource. It performs the following checks:<br><br>
            If the URI is considered a filesystem path (isFilesystemPath(uri)), it returns false.<br>
            If the URI’s scheme (e.g., "http", "ftp", etc.) is null, it returns false.<br>
            If the scheme is "file" or "jar", it returns false.<br><br>
            In all other cases (i.e., the URI is not a local file/jar and has a scheme), it returns true, indicating the URI is remote.</p>
        <p><strong>Comprehensibility:</strong>  This snippet is fairly easy to understand, for the following reasons:<br><br>
            Clear intent: The method name isRemote clearly matches its functionality.<br>
            Straightforward control flow: Each condition is independent and clearly checks a specific disqualifying case for being “remote.”<br>
            Logical order: The snippet rules out local cases early, then defaults to true for all others.<br>
            Readable structure: The switch statement on the scheme is clean, although it could be simplified further by using an if statement instead.<br><br>
            Minor difficulty: The helper method isFilesystemPath(uri) is not shown, so readers must assume or infer its behavior based on context. Otherwise, the snippet is well-structured and easily comprehensible.</p>
      </div>
    </div>
  
    <!-- Snippet 3 -->
    <div class="snippet">
      <h3>Snippet 3</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> Checks whether a given machine type is a CoffMachineType.</p>
        <p><strong>Comprehensibility:</strong> Relatively hard due to unfamiliarity with CoffMachineType. Weird usage of getter with argument.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Verifies if machine type is defined and one of the CoffMachineType constants.</p>
        <p><strong>Comprehensibility:</strong> Understandable via reflection, but unclear what a synthetic field is. Harder if unfamiliar with constants.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> This snippet searches the fields of the `CoffMachineType` class for one whose `getShort` method returns a value equal to the input short. If any such value is found, the snippet returns true; otherwise, it returns false. It also returns false if the input matches a constant (`IMAGE_FILE_MACHINE_UNKNOWN`). These shorts seem to represent something specific, but it's not clear what from the snippet itself.</p>
        <p><strong>Comprehensibility:</strong> The use of Java's reflective features to read the class literal of `CoffMachineType` is relatively complex, and makes it a bit hard to understand the purpose of the method. I also don't really understand what `type` is actually supposed to represent - it seems to be a fake enumeration of some kind, but the actual specification can't be discerned from what we can see. So, I think this snippet is fairly difficult to understand.</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong> T  The method isMachineTypeDefined checks whether the given short value type corresponds to one of the defined machine types in the CoffMachineType class.<br><br>
            It returns false immediately if the type equals IMAGE_FILE_MACHINE_UNKNOWN.<br>
            Otherwise, it uses Java reflection to iterate over all declared fields of the CoffMachineType class.<br>
            For each non-synthetic, static final field, it attempts to get its short value.<br>
            If the value matches the input type, it returns true.<br>
            If no matching constant is found, or an access error occurs for all fields, it returns false.</p>
        <p><strong>Comprehensibility:</strong> This snippet is moderately difficult to understand, due to the following factors:<br><br>
            Challenges:<br><br>
            Use of reflection: The method dynamically inspects fields using Java reflection, which introduces complexity. Understanding what getDeclaredFields(), Modifier.isFinal, and field.getShort(null) do requires deeper knowledge of Java internals.<br>
            Exception handling: The IllegalAccessException is caught and silently ignored, which can obscure potential issues.<br>
            Context required: The meaning of CoffMachineType and what constants it holds isn't visible here, so the snippet relies on external class structure knowledge.<br><br>
            Strengths:<br><br>
            Descriptive method name and clear early exit for the “unknown” type help frame the method's intent.<br>
            Comment reinforces what IMAGE_FILE_MACHINE_UNKNOWN represents.<br><br>
            Overall, it’s a reflective, logic-heavy method that is functional but requires more cognitive effort to parse compared to simple procedural code.
            </p>
      </div>
    </div>
  
    <!-- Snippet 4 -->
    <div class="snippet">
      <h3>Snippet 4</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> Finds the starting position of a query string inside a string, starting from a given index.</p>
        <p><strong>Comprehensibility:</strong> Clear identifiers and simple conditionals make it easier.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Searches for searchStr in str from startPos using case-insensitive comparison.</p>
        <p><strong>Comprehensibility:</strong> Harder due to unfamiliarity with regionMatches; identifiers help.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> This snippet searches a given string for a substring that matches a \"search string\", starting at a fixed start position and going to the end. If it finds such a substring, it returns the index where it starts; if not, it returns the `INDEX_NOT_FOUND` constant. The `startPos` is assumed to be zero if a negative `startPos` is provided.\n\nThe name suggests that it ignores case, but I don't see anything in the logic that obvious implements that part. However, the `true` being passed to `regionMatches` isn't explained at all, so that might control it?"</p>
        <p><strong>Comprehensibility:</strong> The structure is mostly easy to follow: there is some validation logic (lines 2 to 15) followed by the main search (lines 16-18). This method is basically a wrapper around `regionMatches`, which I'm not intimately familiar with. However, I gather just from looking at how it's used here that it 1) takes a surprisingly large number of parameters, and 2) doesn't check that its parameters are valid. That suggests that it's an optimized implementation, and so this wrapper exists to make sure that it's not misused. The validation logic is easy to understand, but figuring out _why_ is a bit trickier: I had to do some thinking about why `regionMatches` is being called the way that it is.</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong> The method indexOfIgnoreCase searches for the first occurrence of searchStr within str, starting at a given startPos, and performs the search case-insensitively.<br><br>
            If either string is null, it returns a sentinel value INDEX_NOT_FOUND.<br>
            If startPos is negative, it resets it to 0.<br>
            If the search string is empty, it returns startPos.<br><br>
            It iterates through str from startPos up to a safe limit and uses a helper method regionMatches to check if the substring at each position matches searchStr, ignoring case.<br>
            If a match is found, it returns the index; otherwise, it returns INDEX_NOT_FOUND.
            </p>
        <p><strong>Comprehensibility:</strong> This snippet is moderately easy to understand, with the following points:<br><br>
            What makes it easy:<br><br>
            Clear structure and flow: The method progresses logically through input validation, boundary adjustment, and main loop.<br>
            Descriptive variable names: Variables like searchStrLen, endLimit, and startPos are intuitive.<br>
            Explicit handling of edge cases: Covers null, empty string, and out-of-bounds starting position.<br><br>
            What adds some complexity:<br><br>
            Dependence on regionMatches: This helper method is not defined here. While it’s likely a wrapper for Java’s String.regionMatches(...), its behavior must be inferred.<br>
            Index math: Calculating endLimit and loop bounds takes a moment to process.<br><br>
            Overall, it’s well-written and readable for someone familiar with Java and string handling. Minor external context is needed for complete clarity.
            </p>
      </div>
    </div>
  
    <!-- Snippet 5 -->
    <div class="snippet">
      <h3>Snippet 5</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> Recursively deletes all files and directories under a given root path.</p>
        <p><strong>Comprehensibility:</strong> Harder due to unclear postVisitDirectory. Assumes dir is Path object passed from FileVisitor.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Recursively deletes a path using a visitor. Returns true if successful.</p>
        <p><strong>Comprehensibility:</strong> Easy; familiar with visitor pattern; identifiers help clarify.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> This snippet implements recursive deletion with force (`rm -rf`) on the input `Path`. It returns true if the root is nonnull and exists, regardless of the outcome of the deletion.</p>
        <p><strong>Comprehensibility:</strong> This was easy _for me_ to understand, but it required domain-specific knowledge of how Java handles file system operations that I _do_ have: I immediately recognized the structure of the `walkFileTree` call with the anonymous visitor, and knew that I only needed to look at the names of the overridden methods and their bodies (i.e., lines 8 and 13) to figure out what the method does.</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong> The method deleteRecursively attempts to delete a directory and all its contents (files and subdirectories) recursively starting from the given Path (root).<br><br>
            If root is null or does not exist, it returns false.<br><br>
            Otherwise, it uses Files.walkFileTree to traverse the file tree rooted at root.<br>
            For each file encountered, it deletes it.<br>
            After visiting each directory, it deletes the directory itself.<br><br>
            If the process completes successfully, it returns true.
            </p>
        <p><strong>Comprehensibility:</strong> This snippet is reasonably clear, especially for developers familiar with Java's NIO APIs.<br><br>
            What makes it understandable:<br><br>
            Logical structure: The intent and flow are straightforward—early exits for invalid input, then recursive deletion using a standard traversal API.<br>
            Standard idiom: The use of Files.walkFileTree with a SimpleFileVisitor is a common pattern for file tree traversal in Java.<br>
            Override annotations: These clarify which methods are part of the visitor lifecycle (visitFile, postVisitDirectory).<br><br>
            What makes it moderately difficult:<br><br>
            Advanced API usage: Understanding Files.walkFileTree, FileVisitResult, and the file visitor pattern requires intermediate Java knowledge.<br>
            Generics: The use of the diamond operator <> in new SimpleFileVisitor<>() might be confusing for some readers not familiar with type inference.<br><br>
            In summary, the snippet is relatively clean and idiomatic but may require background knowledge of Java’s file system traversal mechanisms to be fully comprehended.
            </p>
      </div>
    </div>
  
    <!-- Snippet 6 -->
    <div class="snippet">
      <h3>Snippet 6</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> Returns UTF-8 encoded length of a character sequence.</p>
        <p><strong>Comprehensibility:</strong> Easy to follow due to identifier names and separated logic.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Calculates UTF8 length of a sequence.</p>
        <p><strong>Comprehensibility:</strong> Hard due to encoding/bits; needed to Google concepts.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> This snippet seems to be an optimized implementation of computing the length of a character sequence if it were to be represented as UTF-8. It also contains a check for overflow that causes it to fail if the resulting answer doesn't make sense, that enforces the following invariant: UTF-8 lengths are always longer than or equal to UTF-16 lengths (which is assumed to be the input encoding).</p>
        <p><strong>Comprehensibility:</strong> This snippet is a bit tricky for me to understand, because it requires some domain knowledge of UTF-8 vs UTF-16 that I don't have, and because it performs some operations that are tough to decipher based on that domain knowledge (e.g., the shift on line 14). That said, the _overall_ purpose is pretty clear. But, I am not confident that I understand _why_ each line must be the way that it is: I would need to go have a look at the difference between how Java represents UTF-8 vs UTF-16 encodings to actually understand this code line-by-line.</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong> The method encodedLength calculates the number of bytes required to encode a given CharSequence into UTF-8.<br><br>
            It first assumes that all characters are ASCII (1 byte each), then adjusts the length estimate for characters outside the ASCII range.<br><br>
            It optimizes for ASCII runs using a while loop.<br><br>
            For non-ASCII characters:<br><br>
            Characters < 0x800 are handled with a bitwise expression to determine whether they require 1 or 2 bytes.<br>
            If a character requires more than 2 bytes, the method delegates further processing to encodedLengthGeneral(...), likely a more general (and expensive) fallback.<br><br>
            It includes a sanity check to ensure the final byte length fits in a 32-bit int.
            </p>
        <p><strong>Comprehensibility:</strong> This snippet is difficult to understand, especially for general developers.<br><br>
            What makes it hard:<br><br>
            Bitwise operations: Expressions like ((0x7f - c) >>> 31) are non-obvious and require knowledge of Java's unsigned bit shifts to interpret.<br>
            Missing context: The function encodedLengthGeneral(...) is not shown, making it harder to assess the logic.<br>
            Low-level logic: The method deals with character encoding at a level most developers don’t usually engage with, making the intent and correctness harder to verify without a deep understanding of UTF-8 and UTF-16 encoding differences.<br>
            Deceptively simple variables: Variable names like utf8Length and utf16Length are helpful, but the logic is not intuitive.<br><br>
            What helps:<br><br>
            A comment at the top suggests this is an “optimized implementation,” setting expectations that the code prioritizes performance over readability.<br><br>
            Overall, this snippet is complex, performance-tuned code that trades off comprehensibility for efficiency. It would be difficult to fully understand without a strong background in character encoding and bitwise logic.
            </p>
      </div>
    </div>
  
    <!-- Snippet 7 -->
    <div class="snippet">
      <h3>Snippet 7</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> Takes three floats and returns the lowest positive root.</p>
        <p><strong>Comprehensibility:</strong> Misleading method name; unclear logic despite trying dummy values.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Uses quadratic formula to return smallest positive root.</p>
        <p><strong>Comprehensibility:</strong> Easy after remembering formula; logic is clear with basic math review.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> Quadratic formula; returns `Float.NaN` if it fails. If there are two roots, only returns the positive one. If both roots are positive, it returns the smaller of the two.</p>
        <p><strong>Comprehensibility:</strong> The snippet calls back to grade school math pretty aggressively (e.g., through naming its parameters `a`, `b`, and `c`), and that makes it easier to understand the overall purpose by recognizing the quadratic formula. The swap block (lines 10-14) is also an easily-recognizable pattern to swap via a temporary variable. Overall, then, this is a relatively straightfor</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong> The method lowestPositiveRoot computes the smallest positive root of a quadratic equation of the form ax² + bx + c = 0.<br><br>
            It first calculates the discriminant (det = b² - 4ac).<br>
            If the discriminant is negative, it returns Float.NaN since there are no real roots.<br><br>
            Otherwise, it calculates both roots using the quadratic formula.<br>
            It swaps the roots if necessary so that r1 is the smaller.<br>
            Then it returns the smallest root that is positive.<br>
            If neither root is positive, it returns Float.NaN.
            </p>
        <p><strong>Comprehensibility:</strong> This snippet is quite easy to understand, especially for developers with a basic understanding of algebra.<br><br>
            What makes it easy:<br><br>
            Familiar logic: It directly implements the quadratic formula, which is commonly known.<br>
            Readable math expressions: The formulas are clearly laid out and match the mathematical representation.<br>
            Good structure: The use of intermediate variables like sqrtD, invA, r1, and r2 improves readability.<br>
            Straightforward flow: Conditions are simple, and the logic for choosing the smallest positive root is intuitive.<br><br>
            Minor issue:<br><br>
            The root-swapping logic may briefly confuse those unfamiliar with the need to order the roots before applying the positivity checks—but it's still readable with a second glance.<br><br>
            Overall, this snippet demonstrates good code clarity and logical structure, making it one of the easier ones to comprehend.
            </p>
      </div>
    </div>
  
    <!-- Snippet 8 -->
    <div class="snippet">
      <h3>Snippet 8</h3>
      <div class="participant"><h4>Nadeeshan</h4>
        <p><strong>Summary:</strong> Computes the arctangent (atan) of two float inputs.</p>
        <p><strong>Comprehensibility:</strong> Difficult due to math background required and unclear method purpose.</p>
      </div>
      <div class="participant"><h4>Oscar</h4>
        <p><strong>Summary:</strong> Possibly computes arctangent of x and y using trig functions.</p>
        <p><strong>Comprehensibility:</strong> Cryptic math logic; doesn’t recall arctangent well.</p>
      </div>
      <div class="participant"><h4>Martin</h4>
        <p><strong>Summary:</strong> An implementation of some trigonometric function of x and y? Pretty tough for me to reason about what it's doing, given that I last thought about this kind of trigonometry in like 10th grade. There's some kind of floating point defense going on at the beginning (`n != n`? wtf), which I think is there to deal with the singularity when `x` is near zero.</p>
        <p><strong>Comprehensibility:</strong> This snippet is hard to understand. It does some floating point singularity defense (hard to understand unless you're intimately familiar with numerical methods!) in lines 4-7, followed by some kind of trigonometric math in lines 9-19. Its purpose isn't even clear to me, because I don't remember how atan actually works (trig was a long time ago!) or the relevant identities (why is it adding or subtracting pi or pi/2? I don't know). In other words, this snippet requires two kinds of domain-specific expertise to understand that I don't have: numerical methods for floating point and trigonometry.</p>
      </div>
      <div class="participant"><h4>ChatGPT</h4>
        <p><strong>Summary:</strong> The method atan2 computes the arc tangent of y/x, accounting for the signs of both x and y to determine the correct quadrant of the resulting angle. This mimics the behavior of Math.atan2(y, x).<br><br>
            It first calculates n = y / x.<br><br>
            It handles NaN (Not a Number) cases and indeterminate forms via comparisons like n != n and n - n != n - n.<br><br>
            Based on the sign of x, it determines whether to:<br><br>
            Return atanUnchecked(n) (for x > 0),<br>
            Add or subtract PI to account for quadrant shift (for x < 0),<br>
            Or return x ± HALF_PI depending on y's sign when x == 0.<br><br>
            Finally, it returns x + y when both x and y are zero.
            </p>
        <p><strong>Comprehensibility:</strong> This snippet is difficult to understand for several reasons:<br><br>
            What makes it hard:<br><br>
            Cryptic NaN handling: Using conditions like n != n and n - n != n - n is obscure and relies on deep knowledge of floating-point edge cases.<br>
            Non-standard structure: The control flow is compact and unorthodox, with minimal comments to clarify intent.<br>
            Implicit assumptions: It assumes the existence and behavior of atanUnchecked(...), whose function and correctness cannot be verified from the snippet.<br>
            Confusing return statements: Expressions like x + HALF_PI or x + y for edge cases (e.g., both zero) feel arbitrary and lack explanatory context.<br><br>
            What helps (a little):<br><br>
            The name atan2 gives a strong hint about the intended functionality.<br>
            The structure loosely resembles the logic of standard atan2(y, x) implementations—but in a more compact and less readable way.<br><br>
            In summary, while the general goal is guessable, the implementation details are non-obvious and hard to reason about, making this one of the least comprehensible snippets in the set.
            </p>
      </div>
    </div>
  
  </div>
  

  <div class="phase-section">
    <h2>Phase 2: Ranking</h2>

 <!-- Participant: Nadeeshan -->
<div class="participant-section">
    <h3>Nadeeshan</h3>
    <div class="ranking-labels">
      <div class="ranking-label">1 (easiest)</div>
      <div class="ranking-label">2</div>
      <div class="ranking-label">3</div>
      <div class="ranking-label">4</div>
      <div class="ranking-label">5</div>
      <div class="ranking-label">6</div>
      <div class="ranking-label">7</div>
      <div class="ranking-label">8 (hardest)</div>
    </div>
    <div class="ranking-row">
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-1" onclick="show_snippet(1)">Snippet 1</button>
        <button class="snippet-2" onclick="show_snippet(2)">Snippet 2</button>
        <div class="reasoning-point" onclick="compare([1], [2])" style="position: absolute; top: -4px; right: 60px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 25px; right: 10px;">
           Because both of them are equally understandable to me. Has similar LOC, clear and simple logical separation.
        </div>

      </div>
      
      <div class="ranking-slot"></div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-4" onclick="show_snippet(4)">Snippet 4</button>
        <div class="reasoning-point" onclick="compare([4], [3])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Snippet 3 requires more context understanding than Snippet 4. Also, there is weird syntax in Snippet 3; line 11 takes an argument in a getter, which is not common and passing null looks unnecessary.
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-3" onclick="show_snippet(3)">Snippet 3</button>
        <div class="reasoning-point" onclick="compare([3], [8])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Snippet 8 requires the mathematical definition of "atan".
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-8" onclick="show_snippet(8)">Snippet 8</button>
        <div class="reasoning-point" onclick="compare([8], [5])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Snippet 5 has a clear logic: delete files/directories recursively. It does not need to have a specific mathematical definition to understand the logic like in Snippet 8.
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-5" onclick="show_snippet(5)">Snippet 5</button>
        <div class="reasoning-point" onclick="compare([5], [6])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          The logic used in Snippet 6's encoding is hard to understand. I do not remember the hexadecimal meaning of 0x8 and 0x7.
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-6" onclick="show_snippet(6)">Snippet 6</button>
        <div class="reasoning-point" onclick="compare([6], [7])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Snippet 7 logic is in contradiction with the method name. I thought it returns the lowest positive root from three numbers, but line 2 is unclear.
        </div>
      </div>
      <div class="ranking-slot">
        <button class="snippet-7" onclick="show_snippet(7)">Snippet 7</button>
      </div>
    </div>
  </div>
  
  <!-- Participant: Oscar -->
  <div class="participant-section">
    <h3>Oscar</h3>
    <div class="ranking-row">
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-1" onclick="show_snippet(1)">Snippet 1</button>
        <button class="snippet-3" onclick="show_snippet(3)">Snippet 3</button>
        <button class="snippet-5" onclick="show_snippet(5)">Snippet 5</button>
        <div class="reasoning-point" onclick="compare([1,5], [3])"; style="position: absolute; top: -4px; right: 60px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 25px; left: 10px; width: 360px;">
            It is hard for me to distinguish which one is easier/harder to understand. They have straightforward logic that I am familiar with, and I don't think the usage of a visitor or nested ifs or loops makes one harder/easier to understand than the others.
        </div>
      </div>
      <div class="ranking-slot"></div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-7" onclick="show_snippet(7)">Snippet 7</button>
        <div class="reasoning-point" onclick="compare([7], [2])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          The reason I ranked Snippet 2 after Snippet 7 is that I am not familiar with a URI's scheme and why implementing that logic (in Snippet 2) is enough to check if it is remote. Snippet 7 is straightforward to understand if we remember/know the quadratic formula.
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-2" onclick="show_snippet(2)">Snippet 2</button>
      </div>
      <div class="ranking-slot"></div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-4" onclick="show_snippet(4)">Snippet 4</button>
        <div class="reasoning-point" onclick="compare([4], [6])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Snippet 6 is harder to understand for me because I don't know what the bit shifts are doing to check or determine the sequence length in UTF-8. Snippet 4 is easier to understand, despite it being unclear what regionMatches is doing — overall, I understand what the method is doing.
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-6" onclick="show_snippet(6)">Snippet 6</button>
        <div class="reasoning-point" onclick="compare([6], [8])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          For obvious reasons, atan2 is harder to understand: I don't remember how atan works, the code contains cryptic instructions and I don't know what atanUnchecked is doing -- also, the identifiers here don't help!
        </div>
      </div>
      <div class="ranking-slot">
        <button class="snippet-8" onclick="show_snippet(8)">Snippet 8</button>
      </div>
    </div>
  </div>
  
  <!-- Participant: Martin -->
  <div class="participant-section">
    <h3>Martin</h3>
    <div class="ranking-row">
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-2" onclick="show_snippet(2)">Snippet 2</button>
        <div class="reasoning-point" onclick="compare([2], [1])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 They both implement simple string validation logic. `isRemote` has a shorter, simpler set of rules that it implements, so I ranked it lower. However, I don't think either of these are very difficult: both were pretty trivial to write a specification for.
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-1" onclick="show_snippet(1)">Snippet 1</button>
        <div class="reasoning-point" onclick="compare([2], [1])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
            There is a big gap between these, in my view. `isValidProjectName` is simple string validation, but the other two snippets are implementations of more complex (but reasonably well-known!) algorithms that are pretty easy to recognize. 
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;"></div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-4" onclick="show_snippet(4)">Snippet 4</button>
        <button class="snippet-7" onclick="show_snippet(7)">Snippet 7</button>
        <div class="reasoning-point" onclick="compare([4], [7])"; style="position: absolute; top: -4px; right: 60px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 25px; left: 10px; width: 360px;">
            These two snippets are moderately complex string and float algorithms, respectively. I don't differentiate between them, since both are tricky to get right but doing something pretty well understood.
            (prev:Snippets 4, 5, and 7 are pretty similar, in the sense that each implements a well-known algorithm that I immediately recognized. However, all three are pretty complicated algorithms to get right.)
        </div>

        <div class="reasoning-point" onclick="compare([4,7], [5])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          These three snippets are actually pretty similar: all are implementations of some kind of simple specification that's a bit tricky to get right in practice. I'm actually not even confident that `deleteRecursively` is correct, though, which is why I ranked it above the other two: the relevant Java APIs are quite confusing and easy to get wrong. I think this implementation might leak a file descriptor?

          (prev:I'm actually not even confident that Snippet 5 is correct, which is why I ranked it above the other two: the relevant Java APIs are quite confusing and easy to get wrong. Snippets 4 and 7 are moderately complex string and float algorithms, respectively. I don't differentiate between them.)
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-5" onclick="show_snippet(5)">Snippet 5</button>
        <div class="reasoning-point" onclick="compare([3], [6])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          `isMachineTypeDefined` required me to do true bottom-up reasoning to figure out what it was doing, unlike `deleteRecursively`.
          (prev:Then comes Snippet 3: it also required me to reason through it, since it wasn't clear what it was for just from reading through it once. However, it was noticeably easier to figure out what Snippet 3 is doing compared to Snippet 6.)
        </div>
      </div>
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-3" onclick="show_snippet(3)">Snippet 3</button>
        <div class="reasoning-point" onclick="compare([3], [6])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Both snippets require bottom-up reasoning. However, `encodedLength` requires more domain knowledge to make sense of, since it seems obvious to me that Java programmers should know how the API for the language itself works at a basic level (e.g., \\\"what's a field?\\\" is not a question any Java programmer is going to ask), but `encodedLength` requires understanding UTF-8 vs UTF-16, which many Java programmers won't have had to deal with.        
        </div>
      </div>
      <div class="ranking-slot">
        <button class="snippet-6" onclick="show_snippet(6)">Snippet 6</button>
        <div class="reasoning-point" onclick="compare([6], [8])"; style="top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="top: 60px; right: -160px;">
          💡 <strong>Reason:</strong><br>
          Both require line-by-line reasoning, but `atan2` requires _two_ kinds of domain-specific knowledge (numerical methods + trig) vs just one for `encodedLength` (encodings).
          (prev:Snippet 8 is the toughest: it was the only one where I couldn't follow why it was doing what it was doing.

          Snippet 6 is next: it required me to reason through the code "bottom up" to figure out what it's doing.)          
        </div>
      </div>
      <div class="ranking-slot">
        <button class="snippet-8" onclick="show_snippet(8)">Snippet 8</button>
      </div>
    </div>
  </div>

  <!-- Participant: ChatGPT -->
<div class="participant-section">
    <h3>ChatGPT</h3>
    <div class="ranking-row">
  
      <!-- Position 1: Snippets 1 and 7 -->
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-1" onclick="show_snippet(1)">Snippet 1</button>
        <button class="snippet-7" onclick="show_snippet(7)">Snippet 7</button>
        <div class="reasoning-point" onclick="compare([1], [7])" style="position: absolute; top: -4px; right: 60px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 25px; left: 10px; width: 360px;">
          Q1: Snippets 1 and 7 are procedural, self-contained, and use familiar logic.<br><br>
          Snippet 1 validates a string using simple checks. Snippet 7 implements the quadratic formula clearly.<br><br>
          Both are linear, intuitive, and involve no external APIs or abstractions.
        </div>
        <div class="reasoning-point" onclick="compare([1, 7], [2, 4])" style="position: absolute; top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 60px; right: -160px;">
          Q2: Position 1 snippets use basic logic. Position 2 introduces switch statements, index manipulation, or undefined helpers like <code>isFilesystemPath</code> and <code>regionMatches</code>.
        </div>
      </div>
  
      <!-- Position 2: Snippets 2 and 4 -->
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-2" onclick="show_snippet(2)">Snippet 2</button>
        <button class="snippet-4" onclick="show_snippet(4)">Snippet 4</button>
        <div class="reasoning-point" onclick="compare([2], [4])" style="position: absolute; top: -4px; right: 60px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 25px; left: 10px; width: 360px;">
          Q3: Both snippets are logically structured but rely on external or undefined methods.<br><br>
          Snippet 2: needs understanding of URI schemes.<br>
          Snippet 4: uses string search logic with <code>regionMatches</code>.<br><br>
          Slightly more effort to understand, but still readable.
        </div>
        <div class="reasoning-point" onclick="compare([2, 4], [3])" style="position: absolute; top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 60px; right: -160px;">
          Q4: Snippet 3 (reflection, field modifiers, exceptions) is conceptually more demanding than the procedural structure of 2 and 4.
        </div>
      </div>
  
      <!-- Position 3: Snippet 3 -->
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-3" onclick="show_snippet(3)">Snippet 3</button>
        <div class="reasoning-point" onclick="compare([3], [5])" style="position: absolute; top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 60px; right: -160px;">
          Q5: Snippet 3 uses reflection but is linear. Snippet 5 uses <code>Files.walkFileTree</code>, anonymous classes, and callbacks—making it harder to follow.
        </div>
      </div>
  
      <!-- Position 4: Empty -->
      <div class="ranking-slot"></div>
  
      <!-- Position 5: Snippet 5 -->
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-5" onclick="show_snippet(5)">Snippet 5</button>
        <div class="reasoning-point" onclick="compare([5], [8])" style="position: absolute; top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 60px; right: -160px;">
          Q6: Snippet 5 is harder than reflection, but still structured. Snippet 6 uses bitwise hacks and undefined helpers—less readable.
        </div>
      </div>
  
      <!-- Position 6: Empty -->
      <div class="ranking-slot"></div>
  
      <!-- Position 7: Snippet 8 -->
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-6" onclick="show_snippet(6)">Snippet 6</button>
        <div class="reasoning-point" onclick="compare([6], [8])" style="position: absolute; top: 50px; right: -12px;"></div>
        <div class="tooltip-box" style="position: absolute; top: 60px; right: -160px;">
          Q7: Snippet 6 is hard but scoped. Snippet 8 has cryptic math, fallback logic like <code>x + y</code>, and is more error-prone—therefore harder to follow.
        </div>
      </div>
  
      <!-- Position 8: Snippet 6 -->
      <div class="ranking-slot" style="position: relative;">
        <button class="snippet-8" onclick="show_snippet(8)">Snippet 8</button>
      </div>
    </div>
  </div>
  
  

  </div>

  <div class="phase-section">
    <h2>Phase 3: Reasoning Behind Rankings and Groupings</h2>
  
    <!-- Nadeeshan -->
    <div class="reasoning-box">
      <h3>Nadeeshan</h3>
      <p><strong>Q1: Grouping Snippet 1 and 2:</strong><br>
        Because both of them are equally understandable to me. Has similar LOC, clear and simple logical separation.
      </p>
      <p><strong>Q2: Comparison Position 3 and 4 (Snippet 3 vs Snippet 4):</strong><br>
        Snippet 3 requires more context understanding than Snippet 4. Also, there is weird syntax in Snippet 3; line 11 takes an argument in a getter, which is not common and passing null looks unnecessary.
      </p>
      <p><strong>Q3: Comparison Position 4 and 5 (Snippet 8 vs Snippet 3):</strong><br>
        Snippet 8 requires the mathematical definition of "atan".
      </p>
      <p><strong>Q4: Comparison Position 5 and 6 (Snippet 5 vs Snippet 8):</strong><br>
        Snippet 5 has a clear logic: delete files/directories recursively. It does not need to have a specific mathematical definition to understand the logic like in Snippet 8.
      </p>
      <p><strong>Q5: Comparison Position 6 and 7 (Snippet 6 vs Snippet 5):</strong><br>
        The logic used in Snippet 6's encoding is hard to understand. I do not remember the hexadecimal meaning of 0x8 and 0x7.
      </p>
      <p><strong>Q6: Comparison Position 7 and 8 (Snippet 7 vs Snippet 6):</strong><br>
        Snippet 7 logic is in contradiction with the method name. I thought it returns the lowest positive root from three numbers, but line 2 is unclear.
      </p>
    </div>
  
    <!-- Oscar -->
    <div class="reasoning-box">
      <h3>Oscar</h3>
      <p><strong>Q1: Grouping Snippet 1, 3, and 5:</strong><br>
        It is hard for me to distinguish which one is easier/harder to understand. They have straightforward logic that I am familiar with, and I don't think the usage of a visitor or nested ifs or loops makes one harder/easier to understand than the others.
      </p>
      <p><strong>Q2: Comparison Position 3 and 4 (Snippet 2 vs Snippet 7):</strong><br>
        The reason I ranked Snippet 2 after Snippet 7 is that I am not familiar with a URI's scheme and why implementing that logic (in Snippet 2) is enough to check if it is remote. Snippet 7 is straightforward to understand if we remember/know the quadratic formula.
      </p>
      <p><strong>Q3: Comparison Position 6 and 7 (Snippet 6 vs Snippet 4):</strong><br>
        Snippet 6 is harder to understand for me because I don't know what the bit shifts are doing to check or determine the sequence length in UTF-8. Snippet 4 is easier to understand, despite it being unclear what regionMatches is doing — overall, I understand what the method is doing.
      </p>
      <p><strong>Q4: Comparison Position 7 and 8 (Snippet 6 vs Snippet 8):</strong><br>
        For obvious reasons, atan2 is harder to understand: I don't remember how atan works, the code contains cryptic instructions and I don't know what atanUnchecked is doing -- also, the identifiers here don't help!
      </p>
    </div>
  
    <!-- Martin -->
    <div class="reasoning-box">
      <h3>Martin</h3>
      <p><strong>General Reasoning:</strong></p>
      <p>Snippet 8 is the toughest: it was the only one where I couldn't follow <em>why</em> it was doing what it was doing.</p>
      <p>Snippet 6 is next: it required me to reason through the code "bottom up" to figure out what it's doing.</p>
      <p>Then comes Snippet 3: it also required me to reason through it, since it wasn't clear what it was for just from reading through it once. However, it was noticeably easier to figure out what Snippet 3 is doing compared to Snippet 6.</p>
      <p>Snippets 4, 5, and 7 are pretty similar, in the sense that each implements a well-known algorithm that I immediately recognized. However, all three are pretty complicated algorithms to get right. I'm actually not even confident that Snippet 5 is correct, which is why I ranked it above the other two: the relevant Java APIs are quite confusing and easy to get wrong. Snippets 4 and 7 are moderately complex string and float algorithms, respectively. I don't differentiate between them.</p>
      <p>Snippets 1 and 2 both implement simple string validation logic. Snippet 2 has a shorter, simpler set of rules that it implements, so I ranked it lower. However, I don't think either of these are very difficult: both were pretty trivial to write a specification for.</p>
      <p>There are big gaps, though, that correspond to the blocks of texts above: my ranking looks something like this: 2 . 1 ... 4 7 . 5 ... 3 . 6 ... 8</p>
    </div>
  </div>

  
  <div id="compare-modal" style="display:none; position:fixed; top:10%; left:50%; transform:translateX(-50%); width:90%; max-height:80%; overflow-y:auto; background:#fff; border:1px solid #ccc; padding:20px; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.2); z-index:1002;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
      <h3 style="margin:0;">Compare Snippets</h3>
      <span onclick="document.getElementById('compare-modal').style.display='none'" style="cursor:pointer; font-size:20px; font-weight:bold;">&times;</span>
    </div>
  
    <div id="compare-columns" style="display: flex; gap: 20px;">
      <div id="compare-left" style="flex: 1;"></div>
      <div id="compare-right" style="flex: 1;"></div>
    </div>
  </div>

  
  <div id="snippet-modal" style="display:none; position:fixed; top:10%; left:50%; transform:translateX(-50%); width:80%; max-height:80%; overflow-y:auto; background:#fff; border:1px solid #ccc; padding:20px; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.2); z-index:1002;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
      <h3 id="modal-snippet-title" style="margin:0;">Snippet</h3>
      <div>
        <button onclick="toggleModalTheme()" id="modal-theme-toggle" style="margin-right: 10px; padding: 6px 12px; border-radius: 5px; border: none; background-color: #333; color: white; cursor: pointer;">Switch to Light Mode</button>
        <span onclick="document.getElementById('snippet-modal').style.display='none'" style="cursor:pointer; font-size:20px; font-weight:bold;">&times;</span>
      </div>
    </div>
  
    <div class="code-container" id="modal-code">
      <div class="line-numbers" id="modal-line-numbers"></div>
      <div class="code-content" id="modal-code-content"></div>
    </div>
  </div>

  <script>

  </script>

<script>
    function compare(leftIds, rightIds) {
  const leftContainer = document.getElementById('compare-left');
  const rightContainer = document.getElementById('compare-right');
  leftContainer.innerHTML = '';
  rightContainer.innerHTML = '';

  const getSnippet = id => snippets.find(s => s.id === id);

  // Left side: stacked
  leftIds.forEach(id => {
    const snippet = getSnippet(id);
    if (snippet) {
      const box = document.createElement('div');
      box.className = 'snippet-box';
      box.innerHTML = `<h4>${snippet.title}</h4><pre class="code-content">${snippet.code}</pre>`;
      leftContainer.appendChild(box);
    }
  });

  // Right side: stacked
  rightIds.forEach(id => {
    const snippet = getSnippet(id);
    if (snippet) {
      const box = document.createElement('div');
      box.className = 'snippet-box';
      box.innerHTML = `<h4>${snippet.title}</h4><pre class="code-content">${snippet.code}</pre>`;
      rightContainer.appendChild(box);
    }
  });

  document.getElementById('compare-modal').style.display = 'block';
}

</script>
  <script>
    function getCookie(name) {
        const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? decodeURIComponent(match[2]) : null;
        }

      const snippets = [
      {
        id: 1,
        title: "Snippet 1",
        code: `<span class="keyword">public static</span> <span class="type">boolean</span> <span class="function">isValidProjectName</span>(<span class="type">String</span> name) {
        <span class="keyword">if</span> (name == <span class="literal">null</span>) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">if</span> (name.<span class="function">startsWith</span>(<span class="string">"."</span>)) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">if</span> ((name.<span class="function">length</span>() < <span class="number">1</span>) || (name.<span class="function">length</span>() > MAX_NAME_LENGTH)) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i < name.<span class="function">length</span>(); i++) {
          <span class="type">char</span> c = name.<span class="function">charAt</span>(i);
          <span class="keyword">if</span> (!Character.<span class="function">isLetterOrDigit</span>(c) && !VALID_NAME_SET.<span class="function">contains</span>(c)) {
            <span class="keyword">return</span> <span class="literal">false</span>;
          }
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
      }
      `
            },
            {
              id: 2,
              title: "Snippet 2",
              code: `<span class="keyword">public static</span> <span class="type">boolean</span> <span class="function">isRemote</span>(<span class="type">URI</span> uri) {
        <span class="keyword">if</span> (<span class="function">isFilesystemPath</span>(uri)) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="type">String</span> scheme = uri.<span class="function">getScheme</span>();
        <span class="keyword">if</span> (scheme == <span class="literal">null</span>) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">switch</span> (scheme) {
          <span class="keyword">case</span> <span class="string">"file"</span>:
          <span class="keyword">case</span> <span class="string">"jar"</span>:
            <span class="keyword">return</span> <span class="literal">false</span>;
          <span class="keyword">default</span>:
            <span class="keyword">break</span>;
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
      }
      `
            },
            {
              id: 3,
              title: "Snippet 3",
              code: `<span class="keyword">public static</span> <span class="type">boolean</span> <span class="function">isMachineTypeDefined</span>(<span class="type">short</span> type) {
        <span class="keyword">if</span> (type == IMAGE_FILE_MACHINE_UNKNOWN) {
          <span class="comment">// Unsupported machine type</span>
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">for</span> (<span class="type">Field</span> field : CoffMachineType.<span class="function">class</span>.<span class="function">getDeclaredFields</span>()) {
          <span class="keyword">if</span> (!field.<span class="function">isSynthetic</span>()) {
            <span class="type">int</span> modifiers = field.<span class="function">getModifiers</span>();
            <span class="keyword">if</span> (<span class="function">Modifier.isFinal</span>(modifiers) && <span class="function">Modifier.isStatic</span>(modifiers)) {
              <span class="keyword">try</span> {
                <span class="keyword">if</span> (field.<span class="function">getShort</span>(<span class="literal">null</span>) == type) {
                  <span class="keyword">return</span> <span class="literal">true</span>;
                }
              } <span class="keyword">catch</span> (<span class="type">IllegalAccessException</span> e) {
                <span class="keyword">continue</span>;
              }
            }
          }
        }
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
      `
            },
            {
              id: 4,
              title: "Snippet 4",
              code: `<span class="keyword">public static</span> <span class="type">int</span> <span class="function">indexOfIgnoreCase</span>(<span class="type">CharSequence</span> str, <span class="type">CharSequence</span> searchStr, <span class="type">int</span> startPos) {
        <span class="keyword">if</span> (str == <span class="literal">null</span> || searchStr == <span class="literal">null</span>) {
          <span class="keyword">return</span> INDEX_NOT_FOUND;
        }
        <span class="keyword">if</span> (startPos < <span class="number">0</span>) {
          startPos = <span class="number">0</span>;
        }
        <span class="type">int</span> searchStrLen = searchStr.<span class="function">length</span>();
        <span class="type">int</span> endLimit = str.<span class="function">length</span>() - searchStrLen + <span class="number">1</span>;
        <span class="keyword">if</span> (startPos > endLimit) {
          <span class="keyword">return</span> INDEX_NOT_FOUND;
        }
        <span class="keyword">if</span> (searchStrLen == <span class="number">0</span>) {
          <span class="keyword">return</span> startPos;
        }
        <span class="keyword">for</span> (<span class="type">int</span> i = startPos; i < endLimit; i++) {
          <span class="keyword">if</span> (<span class="function">regionMatches</span>(str, <span class="literal">true</span>, i, searchStr, <span class="number">0</span>, searchStrLen)) {
            <span class="keyword">return</span> i;
          }
        }
        <span class="keyword">return</span> INDEX_NOT_FOUND;
      }
      `
            },
            {
              id: 5,
              title: "Snippet 5",
              code: `<span class="keyword">public static</span> <span class="type">boolean</span> <span class="function">deleteRecursively</span>(@Nullable <span class="type">Path</span> root) <span class="keyword">throws</span> <span class="type">IOException</span> {
        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;
        <span class="keyword">if</span> (!Files.<span class="function">exists</span>(root)) <span class="keyword">return</span> <span class="literal">false</span>;

        Files.<span class="function">walkFileTree</span>(root, <span class="keyword">new</span> <span class="type">SimpleFileVisitor</span>&lt;&gt;() {
          @Override
          <span class="keyword">public</span> <span class="type">FileVisitResult</span> <span class="function">visitFile</span>(<span class="type">Path</span> file, <span class="type">BasicFileAttributes</span> attrs) <span class="keyword">throws</span> <span class="type">IOException</span> {
            Files.<span class="function">delete</span>(file);
            <span class="keyword">return</span> FileVisitResult.CONTINUE;
          }
          @Override
          <span class="keyword">public</span> <span class="type">FileVisitResult</span> <span class="function">postVisitDirectory</span>(<span class="type">Path</span> dir, <span class="type">IOException</span> exc) <span class="keyword">throws</span> <span class="type">IOException</span> {
            Files.<span class="function">delete</span>(dir);
            <span class="keyword">return</span> FileVisitResult.CONTINUE;
          }
        });

        <span class="keyword">return</span> <span class="literal">true</span>;
      }
      `
        },
        {
          id: 6,
          title: "Snippet 6",
          code: `<span class="keyword">public static</span> <span class="type">int</span> <span class="function">encodedLength</span>(<span class="type">CharSequence</span> sequence) {
    <span class="comment">// Optimized implementation</span>
    <span class="type">int</span> utf16Length = sequence.<span class="function">length</span>();
    <span class="type">int</span> utf8Length = utf16Length;
    <span class="type">int</span> i = <span class="number">0</span>;

    <span class="keyword">while</span> (i < utf16Length && sequence.<span class="function">charAt</span>(i) < <span class="literal">0x80</span>) {
      i++;
    }

    <span class="keyword">for</span> (; i < utf16Length; i++) {
      <span class="type">char</span> c = sequence.<span class="function">charAt</span>(i);
      <span class="keyword">if</span> (c < <span class="literal">0x800</span>) {
        utf8Length += ((<span class="literal">0x7f</span> - c) >>> <span class="number">31</span>);
      } <span class="keyword">else</span> {
        utf8Length += <span class="function">encodedLengthGeneral</span>(sequence, i);
        <span class="keyword">break</span>;
      }
    }

    <span class="keyword">if</span> (utf8Length < utf16Length) {
      <span class="keyword">throw new</span> <span class="type">IllegalArgumentException</span>(
        <span class="string">"UTF-8 length does not fit in int: "</span> + (utf8Length + (<span class="literal">1L</span> << <span class="number">32</span>)));
    }

    <span class="keyword">return</span> utf8Length;
  }
  `
        },
        {
          id: 7,
          title: "Snippet 7",
          code: `<span class="keyword">public static</span> <span class="type">float</span> <span class="function">lowestPositiveRoot</span>(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c) {
    <span class="type">float</span> det = b * b - <span class="number">4</span> * a * c;
    <span class="keyword">if</span> (det < <span class="number">0</span>) <span class="keyword">return</span> <span class="type">Float</span>.NaN;

    <span class="type">float</span> sqrtD = (<span class="type">float</span>)<span class="type">Math</span>.<span class="function">sqrt</span>(det);
    <span class="type">float</span> invA = <span class="number">1</span> / (<span class="number">2</span> * a);
    <span class="type">float</span> r1 = (-b - sqrtD) * invA;
    <span class="type">float</span> r2 = (-b + sqrtD) * invA;

    <span class="keyword">if</span> (r1 > r2) {
      <span class="type">float</span> tmp = r2;
      r2 = r1;
      r1 = tmp;
    }

    <span class="keyword">if</span> (r1 > <span class="number">0</span>) <span class="keyword">return</span> r1;
    <span class="keyword">if</span> (r2 > <span class="number">0</span>) <span class="keyword">return</span> r2;
    <span class="keyword">return</span> <span class="type">Float</span>.NaN;
  }
  `
        },
        {
          id: 8,
          title: "Snippet 8",
          code: `<span class="keyword">public static</span> <span class="type">float</span> <span class="function">atan2</span>(<span class="type">float</span> y, <span class="type">float</span> x) {
    <span class="type">float</span> n = y / x;

    <span class="keyword">if</span> (n != n)
      n = (y == x ? <span class="number">1f</span> : <span class="number">-1f</span>);
    <span class="keyword">else if</span> (n - n != n - n)
      x = <span class="number">0f</span>;

    <span class="keyword">if</span> (x > <span class="number">0</span>)
      <span class="keyword">return</span> <span class="function">atanUnchecked</span>(n);
    <span class="keyword">else if</span> (x < <span class="number">0</span>) {
      <span class="keyword">if</span> (y >= <span class="number">0</span>) <span class="keyword">return</span> <span class="function">atanUnchecked</span>(n) + PI;
      <span class="keyword">return</span> <span class="function">atanUnchecked</span>(n) - PI;
    } <span class="keyword">else if</span> (y > <span class="number">0</span>)
      <span class="keyword">return</span> x + HALF_PI;
    <span class="keyword">else if</span> (y < <span class="number">0</span>)
      <span class="keyword">return</span> x - HALF_PI;

    <span class="keyword">return</span> x + y;
  }
  `
        }
      ];


//         // Returns existing or creates a new randomized order of indices
//   function getOrCreateSnippetOrder(length) {
//     const key = 'snippetOrder';
  
//     // Try to load from sessionStorage or cookie
//     let stored = sessionStorage.getItem(key) || getCookie(key);
//     if (stored) {
//       try {
//         const parsed = JSON.parse(stored);
//         if (Array.isArray(parsed) && parsed.length === length) return parsed;
//       } catch {}
//     }
  
//     // Generate new shuffled order of indices
//     const order = Array.from({ length }, (_, i) => i);
//     for (let i = order.length - 1; i > 0; i--) {
//       const j = Math.floor(Math.random() * (i + 1));
//       [order[i], order[j]] = [order[j], order[i]];
//     }
  
//     // Store in sessionStorage and cookie
//     const serialized = JSON.stringify(order);
//     sessionStorage.setItem(key, serialized);
//     document.cookie = `${key}=${encodeURIComponent(serialized)}; path=/; max-age=2592000`; // 30 days
  
//     return order;
//   }
  
//   const originalSnippets = [...snippets]; // Clone BEFORE mutation
//   const order = getOrCreateSnippetOrder(originalSnippets.length); // 1-based [1..8]

//   const shuffled = order.map(i => originalSnippets[i - 1]); // ✅ Convert to 0-based

//   snippets.length = 0;
//   snippets.push(...shuffled);

//   shuffled.forEach((snippet, newIndex) => {
//     snippet.id = newIndex + 1;                      // Maintain new 1-based IDs
//     snippet.title = `Snippet ${newIndex + 1}`;      // Display title
//   });

//   console.log("Final snippet order (titles):", snippets.map(s => s.title));
//   console.log("Final snippet order (ids):", snippets.map(s => s.id));
//   console.log("Server snippet order (1-based):", order.map(i => `Snippet ${i}`));

 </script>
  <script>
    function show_snippet(id) {
    const snippet = snippets.find(s => s.id === id);
    if (!snippet) return;

    document.getElementById('modal-snippet-title').innerText = snippet.title;

    const codeLines = snippet.code.trim().split('\n');

    // ✅ Use innerHTML here to render styled spans correctly
    document.getElementById('modal-code-content').innerHTML = codeLines.join('\n');

    // ✅ Line numbers are just plain numbers
    document.getElementById('modal-line-numbers').innerHTML = codeLines.map((_, i) => i + 1).join('<br>');

    document.getElementById('snippet-modal').style.display = 'block';

    applyModalTheme(); // Keep the theme consistent
    }

    
    function toggleModalTheme() {
      const body = document.body;
      const isLight = body.classList.contains("light-mode");
    
      if (isLight) {
        body.classList.remove("light-mode");
        body.classList.add("dark-mode");
        localStorage.setItem("codeTheme", "dark");
        document.getElementById('modal-theme-toggle').textContent = "Switch to Light Mode";
      } else {
        body.classList.remove("dark-mode");
        body.classList.add("light-mode");
        localStorage.setItem("codeTheme", "light");
        document.getElementById('modal-theme-toggle').textContent = "Switch to Dark Mode";
      }
    }
    
    function applyModalTheme() {
      const theme = localStorage.getItem('codeTheme') || 'light';
      document.body.classList.remove('light-mode', 'dark-mode');
      document.body.classList.add(theme + '-mode');
      document.getElementById('modal-theme-toggle').textContent =
        theme === 'light' ? "Switch to Dark Mode" : "Switch to Light Mode";
    }


//     // Maps from original snippet ID (1–8) to viewer snippet number (1–8)
// function getViewerSnippetNumber(originalId) {
//   const orderStr = sessionStorage.getItem('snippetOrder') || getCookie('snippetOrder');
//   if (!orderStr) return originalId;

//   const order = JSON.parse(orderStr); // 1-based order, like [3,1,4,...]
//   const index = order.indexOf(originalId);
//   return index === -1 ? `#${originalId}` : index + 1;
// }

// // Maps from viewer snippet number to original snippet ID
// function getOriginalSnippetId(viewerId) {
//   const orderStr = sessionStorage.getItem('snippetOrder') || getCookie('snippetOrder');
//   if (!orderStr) return viewerId;

//   const order = JSON.parse(orderStr); // 1-based
//   return order[viewerId - 1]; // returns original snippet ID
// }

</script>
    
<script>
// fetch('responses.json')
//   .then(r => r.json())
//   .then(data => {
//     renderPhase1Responses(data);
//     renderPhase2Rankings(data);
//     renderPhase3(data);
//   });


// const snippetOrder = JSON.parse(sessionStorage.getItem('snippetOrder') || getCookie('snippetOrder'));

// function getViewerSnippetNumber(originalId) {
//   const order = JSON.parse(sessionStorage.getItem('snippetOrder') || getCookie('snippetOrder') || '[]');
//   const index = order.indexOf(originalId);
//   return index === -1 ? `#${originalId}` : index + 1;
// }

// function renderPhase1Responses(data) {
//   const container = document.querySelector('.phase-section');

//   for (let originalId = 1; originalId <= 8; originalId++) {
//     const viewerId = getViewerSnippetNumber(originalId);

//     const snippetDiv = document.createElement('div');
//     snippetDiv.className = 'snippet';
//     snippetDiv.innerHTML = `<h3>Snippet ${viewerId}</h3><button onclick="show_snippet(${viewerId})">View Snippet ${viewerId}</button>`;

//     for (const participant of Object.keys(data.phase1)) {
//       const entry = data.phase1[participant][originalId];
//       if (entry) {
//         snippetDiv.innerHTML += `
//           <div class="participant">
//             <h4>${participant}</h4>
//             <p><strong>Summary:</strong> ${entry.summary}</p>
//             <p><strong>Comprehensibility:</strong> ${entry.comprehensibility || '(Not provided)'}</p>
//           </div>
//         `;
//       }
//     }

//     container.appendChild(snippetDiv);
//   }
// }
// function renderPhase2Rankings(data) {
//   const tbody = document.querySelector('.rank-table tbody');
//   tbody.innerHTML = '';

//   for (let pos = 1; pos <= 8; pos++) {
//     const tr = document.createElement('tr');
//     tr.innerHTML = `<td>${pos}</td>`;

//     ['nadeeshan', 'oscar', 'martin'].forEach(p => {
//       const originalSnips = (data.phase2[p] || {})[pos] || [];
//       const viewerIds = originalSnips.map(getViewerSnippetNumber).join(', ') || '–';
//       tr.innerHTML += `<td>${viewerIds}</td>`;
//     });

//     tbody.appendChild(tr);
//   }
// }
// function renderPhase3(data) {
//   const section = document.querySelector('.phase-section:last-of-type');

//   ['nadeeshan', 'oscar'].forEach(name => {
//     const info = data.phase3[name];
//     if (!info) return;

//     const box = document.createElement('div');
//     box.className = 'reasoning-box';
//     box.innerHTML = `<h3>${name}</h3>`;

//     (info.groupings || []).forEach((g, i) => {
//       const ids = g.snippets.map(getViewerSnippetNumber).join(', ');
//       box.innerHTML += `<p><strong>Q${i + 1}: Grouping Snippets ${ids}</strong><br>${g.reason}</p>`;
//     });

//     (info.comparisons || []).forEach((c, i) => {
//       const from = getViewerSnippetNumber(c.from);
//       const to = getViewerSnippetNumber(c.to);
//       box.innerHTML += `<p><strong>Q${i + 1 + (info.groupings?.length || 0)}: Comparison Snippet ${from} vs Snippet ${to}</strong><br>${c.reason}</p>`;
//     });

//     section.appendChild(box);
//   });

//   // Martin's narrative
//   const martin = data.phase3.martin;
//   if (martin?.narrative) {
//     const box = document.createElement('div');
//     box.className = 'reasoning-box';
//     box.innerHTML = `<h3>Martin</h3><p><strong>General Reasoning:</strong></p><p>${martin.narrative}</p>`;
//     section.appendChild(box);
//   }
// }

</script>

<div id="snippet-menu" class="sticky-menu">
    <button onclick="show_snippet(1)">Snippet 1</button>
    <button onclick="show_snippet(2)">Snippet 2</button>
    <button onclick="show_snippet(3)">Snippet 3</button>
    <button onclick="show_snippet(4)">Snippet 4</button>
    <button onclick="show_snippet(5)">Snippet 5</button>
    <button onclick="show_snippet(6)">Snippet 6</button>
    <button onclick="show_snippet(7)">Snippet 7</button>
    <button onclick="show_snippet(8)">Snippet 8</button>
  </div>
  
</body>
</html>
